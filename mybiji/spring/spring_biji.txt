

---------------------------------------------------------------
IOC

ioc容器
ioc—Inversion of Control，反转控制



DI
DI—Dependency Injection，依赖注入




IOc在spring中的实现

spring的IOC容器就是IOC思想的一个落地的产品实现。IOC容器中管理的组件也叫做bean。在创建bean之前，首先药创建IOC容器，spring提供了IOC容器的两种实现方式：

1、BeanFactory
这是IOC容器的基本实现，是spring内部使用的接口。面向spring本身，不提供给开发人员
2、ApplicationContext
BeanFactory的子接口，提供了更多高级特性，面向所有spring的使用者，几乎所有场所都使用ApplicationContext而不是底层的BeanFactory
3、ApplicationContext的主要实现类

FileSystemXmlApplicationContext

ClassPathXmlApplicationContext  用的多


<dependency>
	<groupId>org.springframework</groupId>
	<artifactId>spring-context</artifactId>
	<version>5.3.1</version>
</dependency>


---------------------------------------------------------------

基于xml管理bean


创建spring配置文件，配置bean

<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">


    <!--
        bean标签：配置一个bean对象，将对象交给IOC容器管理。
        属性：id唯一标识，class设置bean所对应的类型。
    -->

    <bean id="hello" class="com.zhaoxi.spring.pojo.HelloWorld"></bean>


</beans>


获取ioc，获取bean

public class SpringTest {


    @Test
    public void test1() {

//        获取IOC容器
        ApplicationContext ioc = new ClassPathXmlApplicationContext("spring-hello.xml");
//        根据bean的id获取bean对象
        HelloWorld hello = (HelloWorld) ioc.getBean("hello");
//        根据类型获取
        HelloWorld bean = ioc.getBean(HelloWorld.class);
        //根据类型和id获取
        HelloWorld hello1 = ioc.getBean("hello", HelloWorld.class);

        hello.sayHello();
        bean.sayHello();
        hello1.sayHello();
    }

}



spring 通过配置文件读取bean。然后通过反射机制，调用无参构造创建bean对象。所以一定要有无参构造。


-------------------------------------------------------------------

获取bean的方式

1、通过bean标签的id获取。获取到的返回值是object类型
HelloWorld hello = (HelloWorld) ioc.getBean("hello");

2、通过类的class类型(xx.class)获取。 返回值直接就是所需类型的对象。(用的多)
HelloWorld bean = ioc.getBean(HelloWorld.class);

当有多个bean对应同一个类时，会报错。
<bean id="student" class="com.zhaoxi.spring.pojo.Student"></bean>
<bean id="student1" class="com.zhaoxi.spring.pojo.Student"></bean>


3、通过bean标签的id和类的class类型获取。
HelloWorld hello1 = ioc.getBean("hello", HelloWorld.class);



bean中class属性不能写接口。因为不能创建对象。

通过实现的接口也可以获取bean；
例如:
public interface Person{}
public class Student implement Person{}
Person bean = ioc.getBean(Person.class);

如果一个接口有多个实现类，且都配置了bean，根据接口不可以获取bean。因为bean不唯一。


结论：
根据类型获取bean时，在满足bean唯一性的前提下。
其实只是看： 【对象 instanceof 类型】的返回结果
只要返回true就可以获取到。
即通过bean的类型、bean所继承的类的类型、bean所实现的接口的类型都可以获取bean。




-------------------------------------------------------------------
依赖注入

简单来说：就是给类的属性赋值


------------------------
依赖注入之setter注入

<bean id="student2" class="com.zhaoxi.spring.pojo.Student">
	<property name="name" value="zhangsan"></property>
	<property name="age" value="110"></property>
	<property name="id" value="1001"></property>
	<property name="gender" value="男"></property>
</bean>

property通过成员变量的set方法进行赋值。
name是属性名称。(属性名称和set方法有关。去掉set，然后把首字母变小写)
value设置值。

测试：
@Test
public void test2() {

	ApplicationContext ioc = new ClassPathXmlApplicationContext("spring-ioc-xml.xml");
	Student bean = ioc.getBean("student2", Student.class);
	System.out.println(bean);
}
//Student{id=1001, aa=0, age=110, name='zhangsan', gender='男'}




------------------------
依赖注入之构造器注入

<bean id="student3" class="com.zhaoxi.spring.pojo.Student">
	<constructor-arg value="1002"></constructor-arg>
	<constructor-arg value="11"></constructor-arg>
	<constructor-arg value="20"></constructor-arg>
	<constructor-arg value="lisi"></constructor-arg>
	<constructor-arg value="男"></constructor-arg>
</bean>

只有一个有参构造时：可以直接按参数顺序写constructor-arg标签赋值即可



public Student(Integer id, int aa, String name, String gender) {
	this.id = id;
	this.aa = aa;
	this.name = name;
	this.gender = gender;
}

public Student(Integer id, Integer age, String name, String gender) {
	this.id = id;
	this.age = age;
	this.name = name;
	this.gender = gender;
}

<bean id="student3" class="com.zhaoxi.spring.pojo.Student">
	<constructor-arg value="1002"></constructor-arg>
	<constructor-arg value="20" name="age"></constructor-arg>
	<constructor-arg value="lisi" type="java.lang.String"></constructor-arg>
	<constructor-arg value="男"></constructor-arg>
</bean>


当有多个构造器时，可以通过其他属性进行指定。例如使用name指定第三个是给属性名为age的赋值。使用type指定第四个是给类型为string的变量赋值。



------------------------
特殊值处理

value是专门给字面量类型的数据赋值。
不能给类类型、null、list、map等赋值。


<bean id="student5" class="com.zhaoxi.spring.pojo.Student">
	<property name="id" value="1004"></property>
	<property name="name" value="zhangsan"></property>
	<property name="age" value="110"></property>
	<property name="gender">
		<null></null>
	</property>
</bean>

gender属性赋值为null


xml中一些特殊字符不能直接使用。
1、使用xml实体代替
例如：
<  &lt;
>  &gt;




2、使用CDATA节（cdata区）<![CDATA[..内容..]]>
<!-- CDATA中的C代表Character，是文本、字符的含义，CDATA就表示纯文本数据 -->
<!-- XML解析器看到CDATA节就知道这里是纯文本，就不会当作XML标签或属性来解析 -->
<!-- 所以CDATA节中写什么符号都随意 -->


cdata区是一个特殊的标签，不能写在属性中，只能在标签中写。
<bean id="student5" class="com.zhaoxi.spring.pojo.Student">
	<property name="id" value="1004"></property>
	<!--        <property name="name" value="&lt;zhangsan&gt;"></property>-->
	<property name="name">
		<value><![CDATA[< zhangsan >]]></value>
	</property>
	<property name="age" value="110"></property>
	<property name="gender">
		<null></null>
	</property>
</bean>





------------------------
为类类型属性赋值

1、方式一：引用外部已声明的bean

<bean id="clazz1" class="com.zhaoxi.spring.pojo.Clazz">
	<property name="cid" value="1"></property>
	<property name="cname" value="grade1"></property>
</bean>

<bean id="student6" class="com.zhaoxi.spring.pojo.Student">
	<property name="id" value="1007"></property>
	<property name="name" value="zhaoliu"></property>
	<property name="gender" value="男"></property>
	<property name="age" value="20"></property>
	<property name="clazz" ref="clazz1"></property>
</bean>

ref属性：引用IOC容器中某个bean的id，将所对应的bean为属性赋值
clazz通过ref引用ioc容器中的某一个bean的id进行赋值。
不能使用value引用。会报错。


2、方式二：内部bean

<bean id="student7" class="com.zhaoxi.spring.pojo.Student">
    <property name="id" value="1004"></property>
    <property name="name" value="赵六"></property>
    <property name="age" value="26"></property>
    <property name="gender" value="女"></property>
    <property name="clazz">
        <!-- 在一个bean中再声明一个bean就是内部bean -->
        <!-- 内部bean只能用于给属性赋值，不能在外部通过IOC容器获取，因此可以省略id属性 -->
        <bean id="clazzInner" class="com.atguigu.spring.bean.Clazz">
            <property name="clazzId" value="2222"></property>
            <property name="clazzName" value="远大前程班"></property>
        </bean>
    </property>
</bean>




3、方式三：级联属性赋值
<bean id="student8" class="com.zhaoxi.spring.pojo.Student">
    <property name="id" value="1004"></property>
    <property name="name" value="赵六"></property>
    <property name="age" value="26"></property>
    <property name="gender" value="女"></property>
    <!-- 一定先引用某个bean为属性赋值，才可以使用级联方式更新属性 -->
    <property name="clazz" ref="clazz1"></property>
    <property name="clazz.clazzId" value="3333"></property>
    <property name="clazz.clazzName" value="最强王者班"></property>
</bean>




------------------------

为数组类型属性赋值

在Student类中添加以下代码：
private String[] hobbies;
public String[] getHobbies() {
    return hobbies;
}
public void setHobbies(String[] hobbies) {
    this.hobbies = hobbies;
}


<property name="hobbies">
	<array>
		<value>赵熙</value>
		<value>zhangsan</value>
	</array>
</property>

如果数组中的数据是字面量类型的，则array中使用value标签。
若是类类型，则使用ref标签。引用IOC容器中某个bean的id，将所对应的bean为属性赋值





------------------------
为集合类型属性赋值

在Clazz类中添加以下代码：
private List<Student> students;
public List<Student> getStudents() {
    return students;
}
public void setStudents(List<Student> students) {
    this.students = students;
}

<bean id="clazz2" class="com.zhaoxi.spring.pojo.Clazz">
	<property name="cid" value="1"></property>
	<property name="cname" value="grade1"></property>
	<property name="students">
		<list>
			<ref bean="student"></ref>
			<ref bean="student2"></ref>
			<ref bean="student4"></ref>
			<ref bean="student8"></ref>
		</list>
	</property>
</bean>

<bean id="clazz2" class="com.zhaoxi.spring.pojo.Clazz">
	<property name="cid" value="1"></property>
	<property name="cname" value="grade1"></property>
	<!--        <property name="students">-->
	<!--            <list>-->
	<!--                <ref bean="student"></ref>-->
	<!--                <ref bean="student2"></ref>-->
	<!--                <ref bean="student4"></ref>-->
	<!--                <ref bean="student8"></ref>-->
	<!--            </list>-->
	<!--        </property>-->
	<property name="students" ref="studentlist"></property>
</bean>

<util:list id="studentlist">
	<ref bean="student8"></ref>
	<ref bean="student"></ref>
	<ref bean="student2"></ref>
	<ref bean="student4"></ref>
</util:list>
两种方式。
util使用需要引入


若为Set集合类型属性赋值，只需要将其中的list标签改为set标签即可






---------------------------------
为Map集合类型属性赋值

创建教师类Teacher
public class Teacher {
    private Integer teacherId;
    private String teacherName;
}

Student类中添加以下代码
private Map<String, Teacher> teacherMap;


<bean id="teacher" class="com.zhaoxi.spring.pojo.Teacher">
	<property name="teacherId" value="1"></property>
	<property name="teacherName" value="哈哈的"></property>
</bean>
<bean id="teacher2" class="com.zhaoxi.spring.pojo.Teacher">
	<property name="teacherId" value="2"></property>
	<property name="teacherName" value="二宝"></property>
</bean>



<property name="teacherMap">
	<map>
		<entry key="1" value-ref="teacher"></entry>
		<entry key="2" value-ref="teacher2"></entry>
	</map>
</property>


<property name="teacherMap">
	<map>
		<entry key="1" value-ref="teacher"></entry>
		<entry key="2" value-ref="teacher2"></entry>
		<entry>
			<key>
				<value>3</value>
			</key>
			<ref bean="teacher"></ref>
		</entry>
	</map>
</property>


<util:map id="teachermap">
	<entry key="1" value-ref="teacher"></entry>
</util:map>

<property name="teacherMap" ref="teachermap"></property>

以上几种方式均可





使用util:list、util:map标签必须引入相应的命名空间，可以通过idea的提示功能选择


----------------------------------------------------

p命名空间

引入p命名空间后，可以通过以下方式为bean的各个属性赋值

<bean id="student9" class="com.zhaoxi.spring.pojo.Student"
	  p:id="10021222" p:name="azqq" p:age="22" p:gender="男" p:clazz-ref="clazz1"
	  p:teacherMap-ref="teachermap">
</bean>







------------------------------------------------------------------------------------------------

引入外部属性文件，spring管理数据源


创建外部属性文件jdbc.properties
jdbc.driver=com.mysql.cj.jdbc.Driver
jdbc.url=jdbc:mysql://localhost:3306/ssm?useSSL=false&characterEncoding=utf8&serverTimezone=UTC
jdbc.username=root
jdbc.password=123456


<!-- 引入外部属性文件 -->
<context:property-placeholder location="classpath:jdbc.properties"/>

配置bean
<bean id="druidDataSource" class="com.alibaba.druid.pool.DruidDataSource">
    <property name="url" value="${jdbc.url}"/>
    <property name="driverClassName" value="${jdbc.driver}"/>
    <property name="username" value="${jdbc.username}"/>
    <property name="password" value="${jdbc.password}"/>
</bean>

测试：

@Test
public void testDataSource() throws SQLException {
    ApplicationContext ac = new ClassPathXmlApplicationContext("spring-ioc-xml.xml");
    DataSource dataSource = ac.getBean(DataSource.class);
    Connection connection = dataSource.getConnection();
    System.out.println(connection);
}





------------------------------------------------------------------------------------------------

bean的作用域(作用范围)

在Spring中可以通过配置bean标签的scope属性来指定bean的作用域范围，各取值含义：
singleton（默认）：在IOC容器中，这个bean的对象始终为单实例。创建对象的时机：IOC容器初始化时
prototype：这个bean在IOC容器中有多个实例。创建对象的时机：获取bean时.

<bean id="student" class="com.zhaoxi.spring.pojo.Student" scope="prototype">
	<property name="id" value="11"></property>
	<property name="name" value="aaa"></property>
</bean>



如果是在WebApplicationContext环境下还会有另外两个作用域（但不常用）：

request在一个请求范围内有效
session在一个会话范围内有效





------------------------------------------------------------------------------------------------

bean的生命周期


#### 具体的生命周期过程

- bean对象创建（调用无参构造器）
- 给bean对象设置属性
- bean对象初始化之前操作（由bean的后置处理器负责）
- bean对象初始化（需在配置bean时指定初始化方法）
- bean对象初始化之后操作（由bean的后置处理器负责）
- bean对象就绪可以使用
- bean对象销毁（需在配置bean时指定销毁方法）（IOC容器关闭时销毁）



注意：
若bean的作用域为单例时，生命周期的 实例化、依赖注入、初始化(init-method指定的)步骤是在获取IOC容器时执行的。
若bean的作用域为多例时，生命周期的 实例化、依赖注入、初始化(init-method指定的)步骤是在获取bean时执行的。且关闭ioc容器不会调用销毁的方法。



public class User {
    private Integer id;
    private String username;
    private String password;
    private Integer age;

    public User() {
        System.out.println("生命周期：1、创建对象");
    }

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        System.out.println("生命周期：2、依赖注入");
        this.id = id;
    }
	
	......

     public void initMethod() {
        System.out.println("生命周期：3、初始化");
    }

    public void destroyMethod() {
        System.out.println("生命周期：5、销毁");
    }
}



<bean id="user" class="com.zhaoxi.spring.pojo.User" init-method="initMethod" destroy-method="destroyMethod">
	<property name="id" value="1"></property>
	<property name="username" value="admin"></property>
	<property name="password" value="12222"></property>
	<property name="age" value="12"></property>
</bean>

<!-- 使用init-method属性指定初始化方法 -->
<!-- 使用destroy-method属性指定销毁方法 -->

销毁方法是在ioc容器关闭时才会调用.
ApplicationContext没有close()方法。需要使用其子类、子接口



@Test
public void test1() {

	ConfigurableApplicationContext ac = new ClassPathXmlApplicationContext("spring-lifecycle.xml");
	User bean = ac.getBean(User.class);
	System.out.println("生命周期：4、通过IOC容器获取bean并使用");
	System.out.println(bean);
	ac.close();

}



------------------
bean的后置处理器
bean的后置处理器会在生命周期的初始化前后添加额外的操作，需要实现BeanPostProcessor接口，
且配置到IOC容器中，需要注意的是，bean后置处理器不是单独针对某一个bean生效，而是针对IOC容器中所有bean都会执行




public class MyBeanPostProcessor implements BeanPostProcessor {

    @Override
    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
        System.out.println("before");
        return bean;
    }

    @Override
    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
        System.out.println("after");
        return bean;
    }
}


<bean id="beanPostProcessor" class="com.zhaoxi.spring.process.MyBeanPostProcessor"></bean>


@Test
public void test1() {

	ConfigurableApplicationContext ac = new ClassPathXmlApplicationContext("spring-lifecycle.xml");
	User bean = ac.getBean(User.class);
	System.out.println("生命周期：4、通过IOC容器获取bean并使用");
	System.out.println(bean);
	ac.close();

}

---output----

生命周期：1、创建对象
生命周期：2、依赖注入
before
生命周期：3、初始化
after
生命周期：4、通过IOC容器获取bean并使用
User{id=1, username='admin', password='12222', age=12}
生命周期：5、销毁

---output----







--------------------------------------------------------------------------------------------------------
FactoryBean


FactoryBean是Spring提供的一种整合第三方框架的常用机制。
和普通的bean不同，配置一个FactoryBean类型的bean，在获取bean的时候得到的并不是class属性中配置的这个类的对象，而是getObject()方法的返回值。
通过这种机制，Spring可以帮我们把复杂组件创建的详细过程和繁琐细节都屏蔽起来，只把最简洁的使用界面展示给我们。
将来我们整合Mybatis时，Spring就是通过FactoryBean机制来帮我们创建SqlSessionFactory对象的。


public interface FactoryBean<T> {
    String OBJECT_TYPE_ATTRIBUTE = "factoryBeanObjectType";

    @Nullable
    T getObject() throws Exception;

    @Nullable
    Class<?> getObjectType();

    default boolean isSingleton() {
        return true;
    }
}


public class UserFactoryBean implements FactoryBean<User> {

    @Override
    public User getObject() throws Exception {
        return new User();
    }

    @Override
    public Class<?> getObjectType() {
        return User.class;
    }
}


<bean class="com.zhaoxi.spring.factory.UserFactoryBean" id="userFactoryBean"></bean>




@Test
public void test1() throws Exception {

	ApplicationContext ac = new ClassPathXmlApplicationContext("spring-factorybean.xml");
	User bean = ac.getBean(User.class);
	System.out.println(bean);
}






-----------------------------------------------------------------------------------------------------------------------------------------------------

基于xml的自动装配

自动装配：

根据指定的策略，在IOC容器中匹配某一个bean，自动为指定的bean中所依赖的类类型或接口类型属性赋值



场景模拟：

创建类UserController
public class UserController {
    private UserService userService;
    public void setUserService(UserService userService) {
        this.userService = userService;
    }
    public void saveUser(){
        userService.saveUser();
    }
}

创建接口UserService
public interface UserService {
	void saveUser();
}

创建类UserServiceImpl实现接口UserService
public class UserServiceImpl implements UserService {
    private UserDao userDao;
    public void setUserDao(UserDao userDao) {
        this.userDao = userDao;
    }
    @Override
    public void saveUser() {
        userDao.saveUser();
    }
}

创建接口UserDao
public interface UserDao {
	void saveUser();
}

创建类UserDaoImpl实现接口UserDao
public class UserDaoImpl implements UserDao {
    @Override
    public void saveUser() {
        System.out.println("保存成功");
    }
}


配置bean

使用bean标签的autowire属性设置自动装配效果。no和default表示不装配。

自动装配方式：byType

byType：根据类型匹配IOC容器中的某个兼容类型的bean，为属性自动赋值

若在IOC中，没有任何一个兼容类型的bean能够为属性赋值，则该属性不装配，即值为默认值null

若在IOC中，有多个兼容类型的bean能够为属性赋值，则抛出异常NoUniqueBeanDefinitionException

<bean class="com.zhaoxi.spring.Service.Impl.UserServiceImpl" id="userService" autowire="byType"></bean>

<bean class="com.zhaoxi.spring.Dao.Impl.UserDaoImpl" id="userDao"></bean>

<bean class="com.zhaoxi.spring.controller.UserController" id="userController" autowire="byType"></bean>


自动装配方式：byName

byName：将自动装配的属性的属性名，作为bean的id在IOC容器中匹配相对应的bean进行赋值

<bean id="userController"class="com.zhaoxi.spring.controller.UserController" autowire="byName"></bean>
<bean id="userService"class="com.zhaoxi.spring.Service.Impl.UserServiceImpl" autowire="byName"></bean>
<bean id="userServiceImpl"class="com.zhaoxi.spring.Service.Impl.UserServiceImpl" autowire="byName"></bean>
<bean id="userDao" class="com.zhaoxi.spring.Dao.Impl.UserDaoImpl"></bean>
<bean id="userDaoImpl" class="com.zhaoxi.spring.Dao.Impl.UserDaoImpl"></bean> 
（没有userServiceImpl，userDaoImpl这两个名称的变量，如果把userDao，userService注释了就会报错。）

测试：
@Test
public void testAutoWireByXML(){
    ApplicationContext ac = new ClassPathXmlApplicationContext("autowire-xml.xml");
    UserController userController = ac.getBean(UserController.class);
    userController.saveUser();
}







-----------------------------------------------------------------------------------------------------------------------------------------------------
基于注解管理bean



标记与扫描

注解：
和 XML 配置文件一样，注解本身并不能执行，注解本身仅仅只是做一个标记，具体的功能是框架检测
到注解标记的位置，然后针对这个位置按照注解标记的功能来执行具体操作。
本质上：所有一切的操作都是Java代码来完成的，XML和注解只是告诉框架中的Java代码如何执行。

扫描：
Spring 为了知道程序员在哪些地方标记了什么注解，就需要通过扫描的方式，来进行检测。然后根据注解进行后续操作。



标识组件的常用注解

@Component：将类标识为普通组件 
@Controller：将类标识为控制层组件 
@Service：将类标识为业务层组件 
@Repository：将类标识为持久层组件

问：以上四个注解有什么关系和区别？



@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Component
public @interface Controller {
    @AliasFor(
        annotation = Component.class
    )
    String value() default "";
}

通过查看源码我们得知，@Controller、@Service、@Repository这三个注解只是在@Component注解的基础上起了三个新的名字。

对于Spring使用IOC容器管理这些组件来说没有区别。所以@Controller、@Service、@Repository这

三个注解只是给开发人员看的，让我们能够便于分辨组件的作用。

注意：虽然它们本质上一样，但是为了代码的可读性，为了程序结构严谨我们肯定不能随便胡乱标记。



创建控制层组件

@Controller
public class UserController {
}

创建接口UserService

public interface UserService {
}

创建业务层组件UserServiceImpl

@Service
public class UserServiceImpl implements UserService {
}

创建接口UserDao

public interface UserDao {
}

创建持久层组件UserDaoImpl

@Repository
public class UserDaoImpl implements UserDao {
}

类上加上注解，相当于该类加入了ioc容器。


配置按包扫描组件
<context:component-scan base-package="com.zhaoxi.spring"></context:component-scan>


测试：
@Test
public void test1() {

	ApplicationContext ac = new ClassPathXmlApplicationContext("spring-ioc-annotate.xml");
	UserController bean = ac.getBean(UserController.class);
	System.out.println(bean);
	UserService bean1 = ac.getBean(UserService.class);
	System.out.println(bean1);
}




------------------------
扫描组件

情况一：最基本的扫描方式

<context:component-scan base-package="com.zhaoxi.spring"></context:component-scan>

情况二：指定要排除的组件
<context:component-scan base-package="com.zhaoxi.spring">
    <!-- context:exclude-filter标签：指定排除规则 -->
    <!--
        type：设置排除或包含的依据
        type="annotation"，根据注解排除，expression中设置要排除的注解的全类名
        type="assignable"，根据类型排除，expression中设置要排除的类型的全类名
    -->
	<!--        <context:exclude-filter type="assignable" expression="com.zhaoxi.spring.controller.UserController"/>-->
    <context:exclude-filter type="annotation" expression="org.springframework.stereotype.Controller"/>
</context:component-scan>



情况三：仅扫描指定组件

<context:component-scan base-package="com.zhaoxi.spring" use-default-filters="false">
    <!-- context:include-filter标签：指定在原有扫描规则的基础上追加的规则 -->
    <!-- use-default-filters属性：取值false表示关闭默认扫描规则 -->
    <!-- 此时必须设置use-default-filters="false"，因为默认规则即扫描指定包下所有类 -->
    <!--
        type：设置排除或包含的依据
        type="annotation"，根据注解排除，expression中设置要排除的注解的全类名
        type="assignable"，根据类型排除，expression中设置要排除的类型的全类名
     -->
    <context:include-filter type="annotation"expression="org.springframework.stereotype.Controller"/>
    <!--<context:include-filter type="assignable"expression="com.zhaoxi.spring.controller.UserController"/>-->
</context:component-scan>





组件所对应的bean的id


在我们使用XML方式管理bean的时候，每个bean都有一个唯一标识，便于在其他地方引用。现在使用注解后，每个组件仍然应该有一个唯一标识。

默认情况
类名首字母小写就是bean的id。例如：UserController类对应的bean的id就是userController。

自定义bean的id可通过标识组件的注解的value属性设置自定义的bean的id
@Service("userService")//默认为userServiceImpl public class UserServiceImpl implements UserService {}





------------------------------------------------------------------------------------------------
基于注解的自动装配


场景模拟:
参考基于xml的自动装配
在UserController中声明UserService对象
在UserServiceImpl中声明UserDao对象


@Autowired注解
在成员变量上直接标记@Autowired注解即可完成自动装配，不需要提供setXxx()方法。以后我们在项目中的正式用法就是这样。


@Autowired可以标识的位置
1、成员变量
2、set方法上
3、为当前成员变量赋值的有参构造上。


@Autowired工作原理：
1、默认通过bytype的方式。在ioc容器中通过类型匹配某个bean为属性赋值。
2、如果和所需类型匹配的bean不止一个。则自动转换为byname方式实现自动装配的效果。


@Autowired工作流程
首先根据所需要的组件类型到IOC容器中查找
- 能够找到唯一的bean：直接执行装配
- 如果完全找不到匹配这个类型的bean：装配失败
- 和所需类型匹配的bean不止一个
  - 没有@Qualifier注解：根据@Autowired标记位置成员变量的变量名作为bean的id进行匹配
  - 能够找到：执行装配
  - 找不到：装配失败
  - 使用@Qualifier注解：根据@Qualifier注解中指定的名称作为bean的id进行匹配
  - 能够找到：执行装配
  - 找不到：装配失败


@Autowired中有属性required，默认值为true，因此在自动装配无法找到相应的bean时，会装配失败

可以将属性required的值设置为false，则表示能装就装，装不上就不装，此时自动装配的属性为默认值

但是实际开发时，基本上所有需要装配组件的地方都是必须装配的，用不上这个属性。







----------------------------------------------------------------------------------------------------------------------------------------------
AOP



代理模式

二十三种设计模式中的一种，属于结构型模式。它的作用就是通过提供一个代理类，让我们在调用目标方法的时候，
不再是直接对目标方法进行调用，而是通过代理类**间接**调用。
让不属于目标方法核心逻辑的代码从目标方法中剥离出来——**解耦**。
调用目标方法时先调用代理对象的方法，减少对目标方法的调用和打扰，同时让附加功能能够集中在一起也有利于统一维护。





静态代理
静态代理确实实现了解耦，但是由于代码都写死了，完全不具备任何的灵活性。就拿日志功能来说，
将来其他地方也需要附加日志，那还得再声明更多个静态代理类，那就产生了大量重复的代码，日志功能还是分散的，没有统一管理。
提出进一步的需求：将日志功能集中到一个代理类中，将来有任何日志需求，都通过这一个代理类来实现。这就需要使用动态代理技术了。



动态代理

public class DynamicProxy {
    private Object target;

    public DynamicProxy(Object target) {
        this.target = target;
    }

    public Object getProxy() {
        /**
         * newProxyInstance()：创建一个代理实例
         * 其中有三个参数：
         * 1、classLoader：加载动态生成的代理类的类加载器
         * 2、interfaces：目标对象实现的所有接口的class对象所组成的数组
         * 3、invocationHandler：设置代理对象实现目标对象方法的过程，即代理类中如何重写接口中的抽象方法
         */
        ClassLoader classLoader = target.getClass().getClassLoader();
        Class<?>[] interfaces = target.getClass().getInterfaces();
        InvocationHandler invocationHandler = new InvocationHandler() {

            @Override
            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                /**
                 * proxy：代理对象
                 * method：代理对象需要实现的方法，即其中需要重写的方法
                 * args：method所对应方法的参数
                 */
                Object result = null;
                try {
                    System.out.println("[动态代理][日志] " + method.getName() + "，参数：" + Arrays.toString(args));
                    result = method.invoke(target, args);
                    System.out.println("[动态代理][日志] " + method.getName() + "，结 果：" + result);
                } catch (Exception e) {
                    e.printStackTrace();
                    System.out.println("[动态代理][日志] " + method.getName() + "，异常：" + e.getMessage());
                } finally {
                    System.out.println("[动态代理][日志] " + method.getName() + "，方法执行完毕");
                }
                return result;
            }
        };
        return Proxy.newProxyInstance(classLoader, interfaces, invocationHandler);
    }
}








--------------------------------------------------------------------
AOP概念及相关术语

概述
AOP（Aspect Oriented Programming）是一种设计思想，是软件设计领域中的面向切面编程，
它是面向对象编程的一种补充和完善，它以通过预编译方式和运行期动态代理方式实现在不修改源代码的情况下给程序动态统一添加额外功能的一种技术。


相关术语

横切关注点
从每个方法中抽取出来的同一类非核心业务。在同一个项目中，我们可以使用多个横切关注点对相关方法进行多个不同方面的增强。
这个概念不是语法层面天然存在的，而是根据附加功能的逻辑上的需要：有十个附加功能，就有十个横切关注点。


通知

每一个横切关注点上要做的事情都需要写一个方法来实现，这样的方法就叫通知方法。

- 前置通知：在被代理的目标方法**前**执行
- 返回通知：在被代理的目标方法**成功结束**后执行（**寿终正寝**）
- 异常通知：在被代理的目标方法**异常结束**后执行（**死于非命**）
- 后置通知：在被代理的目标方法**最终结束**后执行（**盖棺定论**）
- 环绕通知：使用try...catch...finally结构围绕**整个**被代理的目标方法，包括上面四种通知对应的所有位置


切面
封装通知方法的类


目标
被代理的目标对象。

代理
向目标对象应用通知之后创建的代理对象。

连接点
这也是一个纯逻辑概念，不是语法定义的。


切入点
定位连接点的方式。

每个类的方法中都包含多个连接点，所以连接点是类中客观存在的事物（从逻辑上来说）。

如果把连接点看作数据库中的记录，那么切入点就是查询记录的 SQL 语句。

Spring 的 AOP 技术可以通过切入点定位到特定的连接点。

切点通过 org.springframework.aop.Pointcut 接口进行描述，它使用类和方法作为连接点的查询条件。



作用
- 简化代码：把方法中固定位置的重复的代码**抽取**出来，让被抽取的方法更专注于自己的核心功能，提高内聚性。
- 代码增强：把特定的功能封装到切面类中，看哪里有需要，就往上套，被**套用**了切面逻辑的方法就被切面给增强了。









--------------------------------------------------------------------
基于注解的AOP

AspectJ：本质上是静态代理，**将代理逻辑“织入”被代理的目标类编译得到的字节码文件**，所以最终效果是动态的。weaver就是织入器。Spring只是借用了AspectJ中的注解。

AspectJ是aop思想的重要实现。



添加依赖
<!-- spring-aspects会帮我们传递过来aspectjweaver -->
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-aspects</artifactId>
    <version>5.3.1</version>
</dependency>


准备被代理的目标资源
public interface Calculator {
    int add(int i, int j);
    int sub(int i, int j);
    int mul(int i, int j);
    int div(int i, int j);
}



实现类：
@Component
public class CalculatorPureImpl implements Calculator {
    @Override
    public int add(int i, int j) {
        int result = i + j;
        System.out.println("方法内部 result = " + result);
        return result;
    }
    @Override
    public int sub(int i, int j) {
        int result = i - j;
        System.out.println("方法内部 result = " + result);
        return result;
    }
    @Override
    public int mul(int i, int j) {
        int result = i * j;
        System.out.println("方法内部 result = " + result);
        return result;
    }
    @Override
    public int div(int i, int j) {
        int result = i / j;
        System.out.println("方法内部 result = " + result);
        return result;
    }
}

创建切面类并配置
// @Aspect表示这个类是一个切面类
@Aspect
// @Component注解保证这个切面类能够放入IOC容器
@Component
public class LogAspect {

    @Before("execution(public int com.atguigu.aop.annotation.CalculatorImpl.*(..))")
	public void beforeMethod(JoinPoint joinPoint){
	String methodName = joinPoint.getSignature().getName();
	String args = Arrays.toString(joinPoint.getArgs());
	System.out.println("Logger-->前置通知，方法名："+methodName+"，参数："+args);
	}
	
    @After("execution(* com.atguigu.aop.annotation.CalculatorImpl.*(..))")
	public void afterMethod(JoinPoint joinPoint){
		String methodName = joinPoint.getSignature().getName();
		System.out.println("Logger-->后置通知，方法名："+methodName);
	}
	
    @AfterReturning(value = "execution(*com.atguigu.aop.annotation.CalculatorImpl.*(..))", returning = "result")
	public void afterReturningMethod(JoinPoint joinPoint, Object result){
		String methodName = joinPoint.getSignature().getName();
		System.out.println("Logger-->返回通知，方法名："+methodName+"，结果："+result);
	} 
	
    @AfterThrowing(value = "execution(*com.atguigu.aop.annotation.CalculatorImpl.*(..))", throwing = "ex")
	public void afterThrowingMethod(JoinPoint joinPoint, Throwable ex){
		String methodName = joinPoint.getSignature().getName();
		System.out.println("Logger-->异常通知，方法名："+methodName+"，异常："+ex);
	}
	
    @Around("execution(* com.atguigu.aop.annotation.CalculatorImpl.*(..))")
	public Object aroundMethod(ProceedingJoinPoint joinPoint){
        String methodName = joinPoint.getSignature().getName();
		String args = Arrays.toString(joinPoint.getArgs());
		Object result = null;
        try {
            System.out.println("环绕通知-->目标对象方法执行之前");
            //目标对象（连接点）方法的执行
            result = joinPoint.proceed();
            System.out.println("环绕通知-->目标对象方法返回值之后");
		} catch (Throwable throwable) {
            throwable.printStackTrace();
            System.out.println("环绕通知-->目标对象方法出现异常时");
		} finally {
			System.out.println("环绕通知-->目标对象方法执行完毕");
		}
		return result;
	}
}



在Spring的配置文件中配置：
<!--
	基于注解的AOP的实现：
	1、将目标对象和切面交给IOC容器管理（注解+扫描）
	2、开启基于注解的aop功能
	3、将切面类通过注解@Aspect标识
-->
<context:component-scan base-package="com.zhaoxi.spring.aop.annotation"></context:component-scan>

开启基于注解的aop功能
<aop:aspectj-autoproxy /> 




各种通知

前置通知：使用@Before注解标识，在被代理的目标方法前执行

返回通知：使用@AfterReturning注解标识，在被代理的目标方法成功结束后执行（寿终正寝）

异常通知：使用@AfterThrowing注解标识，在被代理的目标方法异常结束后执行（死于非命）

后置通知：使用@After注解标识，在被代理的目标方法最终结束后执行（盖棺定论）

环绕通知：使用@Around注解标识，使用try...catch...finally结构围绕整个被代理的目标方法，包括上面四种通知对应的所有位置


各种通知的执行顺序：

- Spring版本5.3.x以前：
  - 前置通知
  - 目标操作
  - 后置通知
  - 返回通知或异常通知
- Spring版本5.3.x以后：
  - 前置通知
  - 目标操作
  - 返回通知或异常通知
  - 后置通知


切入点表达式语法

execution(public int com.zhaoxi.spring.aop.annotation.Calculator.div(int,int))  基本的结构
execution(public int com.zhaoxi.spring.aop.annotation.Calculator.div(..))  ..表示参数列表任意

execution开头。(固定格式)
- 用*号代替“权限修饰符”和“返回值”部分表示“权限修饰符”和“返回值”不限
- 在包名的部分，一个“*”号只能代表包的层次结构中的一层，表示这一层是任意的。*
  - *例如：*.Hello匹配com.Hello，不匹配com.atguigu.Hello
- 在包名的部分，使用“*..”表示包名任意、包的层次深度任意*
- *在类名的部分，类名部分整体用*号代替，表示类名任意
- 在类名的部分，可以使用*号代替类名的一部分*
  - *例如：*Service匹配所有名称以Service结尾的类或接口
- 在方法名部分，可以使用*号表示方法名任意*
- *在方法名部分，可以使用*号代替方法名的一部分
  - 例如：*Operation匹配所有方法名以Operation结尾的方法
- ​	在方法参数列表部分，使用(..)表示参数列表任意
- 在方法参数列表部分，使用(int,..)表示参数列表以一个int类型的参数开头
- 在方法参数列表部分，基本数据类型和对应的包装类型是不一样的
  - 切入点表达式中使用 int 和实际方法中 Integer 是不匹配的
- 在方法返回值部分，如果想要明确指定一个返回值类型，那么必须同时写明权限修饰符
  - 例如：execution(public int *..*Service.*(.., int)) 正确*
  - *例如：execution(* int *..*Service.*(.., int)) 错误






----------------------------------------------------------
重用切入点表达式


声明
@Pointcut("execution(* com.atguigu.aop.annotation.*.*(..))")
public void pointCut(){}



在同一个切面中使用
@Before("pointCut()")
public void beforeMethod(JoinPoint joinPoint){
    String methodName = joinPoint.getSignature().getName();
    String args = Arrays.toString(joinPoint.getArgs());
    System.out.println("Logger-->前置通知，方法名："+methodName+"，参数："+args);
}


在不同切面中使用
@Before("com.atguigu.aop.CommonPointCut.pointCut()")
public void beforeMethod(JoinPoint joinPoint){
    String methodName = joinPoint.getSignature().getName();
    String args = Arrays.toString(joinPoint.getArgs());
    System.out.println("Logger-->前置通知，方法名："+methodName+"，参数："+args);
}



----------------------------------------------------------
获取通知的相关信息


获取连接点信息
获取连接点信息可以在通知方法的参数位置设置JoinPoint类型的形参


获取目标方法的返回值
@AfterReturning中的属性returning，用来将通知方法的某个形参，接收目标方法的返回值
@AfterReturning(value = "execution(* com.atguigu.aop.annotation.CalculatorImpl.*(..))", returning = "result")
    public void afterReturningMethod(JoinPoint joinPoint, Object result){
    String methodName = joinPoint.getSignature().getName();
    System.out.println("Logger-->返回通知，方法名："+methodName+"，结果："+result);
}




获取目标方法的异常
@AfterThrowing中的属性throwing，用来将通知方法的某个形参，接收目标方法的异常

@AfterThrowing(value = "execution(* com.atguigu.aop.annotation.CalculatorImpl.*(..))", throwing = "ex")
    public void afterThrowingMethod(JoinPoint joinPoint, Throwable ex){
    String methodName = joinPoint.getSignature().getName();
    System.out.println("Logger-->异常通知，方法名："+methodName+"，异常："+ex);
}



----------------------------------------------------------
环绕通知
@Around("execution(* com.atguigu.aop.annotation.CalculatorImpl.*(..))")
public Object aroundMethod(ProceedingJoinPoint joinPoint){
    String methodName = joinPoint.getSignature().getName();
    String args = Arrays.toString(joinPoint.getArgs());
    Object result = null;
    try {
        System.out.println("环绕通知-->目标对象方法执行之前");
        //目标方法的执行，目标方法的返回值一定要返回给外界调用者
        result = joinPoint.proceed();
        System.out.println("环绕通知-->目标对象方法返回值之后");
    } catch (Throwable throwable) {
        throwable.printStackTrace();
        System.out.println("环绕通知-->目标对象方法出现异常时");
    } finally {
        System.out.println("环绕通知-->目标对象方法执行完毕");
    }
    return result;
}


----------------------------------------------------------
切面的优先级


相同目标方法上同时存在多个切面时，切面的优先级控制切面的内外嵌套顺序。

- 优先级高的切面：外面
- 优先级低的切面：里面

使用@Order注解可以控制切面的优先级：

- @Order(较小的数)：优先级高
- @Order(较大的数)：优先级低






--------------------------------------------------------------------------------------------------------------------
基于XML的AOP（了解）



<context:component-scan base-package="com.zhaoxi.spring.aop.xml"></context:component-scan>
<aop:config>
    <!--配置切面类-->
    <aop:aspect ref="loggerAspect">
        <aop:pointcut id="pointCut" expression="execution(*com.atguigu.aop.xml.CalculatorImpl.*(..))"/>
        <aop:before method="beforeMethod" pointcut-ref="pointCut"></aop:before>
        <aop:after method="afterMethod" pointcut-ref="pointCut"></aop:after>
        <aop:after-returning method="afterReturningMethod" returning="result"pointcut-ref="pointCut"></aop:after-returning>
        <aop:after-throwing method="afterThrowingMethod" throwing="ex" pointcut-ref="pointCut"></aop:after-throwing>
        <aop:around method="aroundMethod" pointcut-ref="pointCut"></aop:around>
    </aop:aspect>
    <aop:aspect ref="validateAspect" order="1">
        <aop:before method="validateBeforeMethod" pointcut-ref="pointCut">
        </aop:before>
    </aop:aspect>
</aop:config>









--------------------------------------------------------------------------------------------------------------------
声明式事务



---------------------------------------
JdbcTemplate

Spring 框架对 JDBC 进行封装，使用 JdbcTemplate 方便实现对数据库操作


加入依赖



<!-- Spring 持久化层支持jar包 -->
<!-- Spring 在执行持久化层操作、与持久化层技术进行整合过程中，需要使用orm、jdbc、tx三个jar包 -->
<!-- 导入 orm 包就可以通过 Maven 的依赖传递性把其他两个也导入 -->
<dependency>
	<groupId>org.springframework</groupId>
	<artifactId>spring-orm</artifactId>
	<version>5.3.1</version>
</dependency>
<!-- Spring 测试相关 -->
<dependency>
	<groupId>org.springframework</groupId>
	<artifactId>spring-test</artifactId>
	<version>5.3.1</version>
</dependency>



配置spring配置文件

<context:property-placeholder location="classpath:jdbc-config.properties"/>


<bean class="com.alibaba.druid.pool.DruidDataSource" id="druidDataSource">
	<property name="driverClassName" value="${jdbc.driver}"></property>
	<property name="url" value="${jdbc.url}"></property>
	<property name="username" value="${jdbc.username}"></property>
	<property name="password" value="${jdbc.password}"></property>
</bean>


<bean class="org.springframework.jdbc.core.JdbcTemplate" id="jdbcTemplate">
	<property name="dataSource" ref="druidDataSource"></property>
</bean>


测试：

// @RunWith(SpringJUnit4ClassRunner.class) 指定当前测试类在spring的测试环境中执行。此时就可以通过注入的方式直接获取ioc容器中的bean。
// @ContextConfiguration({"spring-transaction.xml"}) 指定spring的配置文件。
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration("classpath:spring-transaction.xml")
public class JdbcTemplateTest {

    @Autowired
    private JdbcTemplate jdbcTemplate;

    @Test
    public void test1() {

        jdbcTemplate.update("insert into t_user values (null,?,?,?,?,?)", 12, 12, 12, 12, 12);
        List<Map<String, Object>> maps = jdbcTemplate.queryForList("select * from t_user;");
        System.out.println(maps);


    }
}








--------------------------------------------------------------------

声明式事务概念




--------------------------------------
编程式事务

事务功能的相关操作全部通过自己编写代码来实现：
Connection conn = ...;
try {
    // 开启事务：关闭事务的自动提交
    conn.setAutoCommit(false);
    // 核心操作
    // 提交事务
    conn.commit();
}catch(Exception e){
    // 回滚事务
    conn.rollBack();
}finally{
    // 释放数据库连接
    conn.close();
}

编程式的实现方式存在缺陷：
- 细节没有被屏蔽：具体操作过程中，所有细节都需要程序员自己来完成，比较繁琐。
- 代码复用性不高：如果没有有效抽取出来，每次实现功能都需要自己编写代码，代码就没有得到复用。






--------------------------------------
声明式事务

既然事务控制的代码有规律可循，代码的结构基本是确定的，所以框架就可以将固定模式的代码抽取出来，进行相关的封装。

封装起来后，我们只需要在配置文件中进行简单的配置即可完成操作。

- 好处1：提高开发效率
- 好处2：消除了冗余的代码
- 好处3：框架会综合考虑相关领域中在实际开发环境下有可能遇到的各种问题，进行了健壮性、性能等各个方面的优化

所以，我们可以总结下面两个概念：
- 编程式：自己写代码实现功能
- 声明式：通过配置让框架实现功能







----------------------------------------------------------------------------
基于注解的声明式事务


加入依赖
<dependency>
	<groupId>org.springframework</groupId>
	<artifactId>spring-context</artifactId>
	<version>5.3.1</version>
</dependency>
<!-- Spring 持久化层支持jar包 -->
<!-- Spring 在执行持久化层操作、与持久化层技术进行整合过程中，需要使用orm、jdbc、tx三个jar包 -->
<!-- 导入 orm 包就可以通过 Maven 的依赖传递性把其他两个也导入 -->
<dependency>
	<groupId>org.springframework</groupId>
	<artifactId>spring-orm</artifactId>
	<version>5.3.1</version>
</dependency>

<!-- MySQL驱动 -->
<dependency>
	<groupId>mysql</groupId>
	<artifactId>mysql-connector-java</artifactId>
	<version>8.0.16</version>
</dependency>
<!-- 数据源 -->
<dependency>
	<groupId>com.alibaba</groupId>
	<artifactId>druid</artifactId>
	<version>1.0.31</version>
</dependency>




配置Spring的配置文件，添加事务配置
<bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
    <property name="dataSource" ref="dataSource"></property>
</bean>

<!--
    开启事务的注解驱动
    通过注解@Transactional所标识的方法或标识的类中所有的方法，都会被事务管理器管理事务
-->
<!-- transaction-manager属性的默认值是transactionManager，如果事务管理器bean的id正好就
是这个默认值，则可以省略这个属性 -->
<tx:annotation-driven transaction-manager="transactionManager" />

导入的名称空间需要 tx 结尾的那个


添加事务注解
因为service层表示业务逻辑层，一个方法表示一个完成的功能，因此处理事务一般在service层处理
在BookServiceImpl的buybook()添加注解@Transactional



@Transactional注解标识的位置
@Transactional标识在方法上，咋只会影响该方法
@Transactional标识的类上，咋会影响类中所有的方法


--------------------------------------------------------------
事务属性：只读 @Transactional(readOnly = true)

对一个查询操作来说，如果我们把它设置成只读，就能够明确告诉数据库，这个操作不涉及写操作。这样数据库就能够针对查询操作来进行优化。

对增删改操作设置只读会抛出下面异常：
Caused by: java.sql.SQLException: Connection is read-only. Queries leading to data modification are not allowed


--------------------------------------------------------------
事务属性：超时 @Transactional(timeout = 3)

事务在执行过程中，有可能因为遇到某些问题，导致程序卡住，从而长时间占用数据库资源。
而长时间占用资源，大概率是因为程序运行出现了问题（可能是Java程序或MySQL数据库或网络连接等等）。
此时这个很可能出问题的程序应该被回滚，撤销它已做的操作，事务结束，把资源让出来，让其他正常程序可以执行。
概括来说就是一句话：超时回滚，释放资源。

执行过程中抛出异常：
org.springframework.transaction.**TransactionTimedOutException**: Transaction timed out:


--------------------------------------------------------------
事务属性：回滚策略

声明式事务默认只针对运行时异常回滚，编译时异常不回滚。

可以通过@Transactional中相关属性设置回滚策略

- rollbackFor属性：需要设置一个Class类型的对象
- rollbackForClassName属性：需要设置一个字符串类型的全类名
- noRollbackFor属性：需要设置一个Class类型的对象
- noRollbackForClassName属性：需要设置一个字符串类型的全类名


使用方式：
@Transactional(rollbackFor = ArithmeticException.class)
@Transactional(rollbackForClassName = "java.lang.ArithmeticException")
@Transactional(noRollbackFor = ArithmeticException.class)
@Transactional(noRollbackForClassName = "java.lang.ArithmeticException")



--------------------------------------------------------------
事务属性：事务隔离级别

数据库系统必须具有隔离并发运行各个事务的能力，使它们不会相互影响，避免各种并发问题。一个事务与其他事务隔离的程度称为隔离级别。

SQL标准中规定了多种事务隔离级别，不同隔离级别对应不同的干扰程度，隔离级别越高，数据一致性就越好，但并发性越弱。



隔离级别一共有四种：

- 读未提交：READ UNCOMMITTED

允许Transaction01读取Transaction02未提交的修改。

- 读已提交：READ COMMITTED、

要求Transaction01只能读取Transaction02已提交的修改。

- 可重复读：REPEATABLE READ

确保Transaction01可以多次从一个字段中读取到相同的值，即Transaction01执行期间禁止其它事务对这个字段进行更新。

- 串行化：SERIALIZABLE

确保Transaction01可以多次从一个表中读取到相同的行，在Transaction01执行期间，禁止其它事务对这个表进行添加、更新、删除操作。
可以避免任何并发问题，但性能十分低下。


隔离级别    脏读   不可重复读   幻读
READ UNCOMMITTED 有 有 有 
READ COMMITTED 无 有 有 
REPEATABLE READ 无 无 有 
SERIALIZABLE 无 无 无 



使用方式：
@Transactional(isolation = Isolation.DEFAULT)//使用数据库默认的隔离级别
@Transactional(isolation = Isolation.READ_UNCOMMITTED)//读未提交
@Transactional(isolation = Isolation.READ_COMMITTED)//读已提交
@Transactional(isolation = Isolation.REPEATABLE_READ)//可重复读
@Transactional(isolation = Isolation.SERIALIZABLE)//串行化








--------------------------------------------------------------
事务属性：事务传播行为


当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。
例如：方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行。

@Autowired
private CheckoutService checkoutService;
public void checkout(Integer[] bookIds, Integer userId){
    checkoutService.checkout(bookIds, userId);
}

@Service
public class CheckoutServiceImpl implements CheckoutService {
    @Autowired
    private BookService bookService;
	
    @Override
    @Transactional
    //一次购买多本图书
    public void checkout(Integer[] bookIds, Integer userId) {
        for (Integer bookId : bookIds) {
            bookService.buyBook(bookId, userId);
        }
    }
}


@Transactional
public void buyBook(Integer bookId, Integer userId) {
    try {
        TimeUnit.SECONDS.sleep(5);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    //查询图书的价格
    Integer price = bookDao.getPriceByBookId(bookId);
    //更新图书的库存
    bookDao.updateStock(bookId);
    //更新用户的余额
    bookDao.updateBalance(userId, price);
    //System.out.println(1/0);
}


可以通过@Transactional中的propagation属性设置事务传播行为。
修改BookServiceImpl中buyBook()上，注解@Transactional的propagation属性

@Transactional(propagation = Propagation.REQUIRED)，默认情况，表示如果当前线程上有已经开

启的事务可用，那么就在这个事务中运行。经过观察，购买图书的方法buyBook()在checkout()中被调

用，checkout()上有事务注解，因此在此事务中执行。所购买的两本图书的价格为80和50，而用户的余额为100，
因此在购买第二本图书时余额不足失败，导致整个checkout()回滚，即只要有一本书买不了，就都买不了

@Transactional(propagation = Propagation.REQUIRES_NEW)，表示不管当前线程上是否有已经开启的事务，都要开启新事务。
同样的场景，每次购买图书都是在buyBook()的事务中执行，因此第一本图书购买成功，事务结束，
第二本图书购买失败，只在第二次的buyBook()中回滚，购买第一本图书不受影响，即能买几本就买几本





















----------------------------------------------------------------------------------------------------------------------------------
基于XML的声明式事务



将Spring配置文件中去掉tx:annotation-driven 标签，并添加配置：


<aop:config>
    <!-- 配置事务通知和切入点表达式 -->
    <aop:advisor advice-ref="txAdvice" pointcut="execution(*com.atguigu.spring.tx.xml.service.impl.*.*(..))"></aop:advisor>
</aop:config>
<!-- tx:advice标签：配置事务通知 -->
<!-- id属性：给事务通知标签设置唯一标识，便于引用 -->
<!-- transaction-manager属性：关联事务管理器 -->
<tx:advice id="txAdvice" transaction-manager="transactionManager">
    <tx:attributes>
        <!-- tx:method标签：配置具体的事务方法 -->
        <!-- name属性：指定方法名，可以使用星号代表多个字符 -->
        <tx:method name="get*" read-only="true"/>
        <tx:method name="query*" read-only="true"/>
        <tx:method name="find*" read-only="true"/>
        <!-- read-only属性：设置只读属性 -->
        <!-- rollback-for属性：设置回滚的异常 -->
        <!-- no-rollback-for属性：设置不回滚的异常 -->
        <!-- isolation属性：设置事务的隔离级别 -->
        <!-- timeout属性：设置事务的超时属性 -->
        <!-- propagation属性：设置事务的传播行为 -->
        <tx:method name="save*" read-only="false" rollback-for="java.lang.Exception" propagation="REQUIRES_NEW"/>
        <tx:method name="update*" read-only="false" rollback-for="java.lang.Exception" propagation="REQUIRES_NEW"/>
        <tx:method name="delete*" read-only="false" rollback-for="java.lang.Exception" propagation="REQUIRES_NEW"/>
    </tx:attributes>
</tx:advice>




注意：基于xml实现的声明式事务，必须引入aspectJ的依赖

<dependency>
	<groupId>org.springframework</groupId>
	<artifactId>spring-aspects</artifactId>
	<version>5.3.1</version>
</dependency>





























































































