
springboot配置文件


SpringBoot使用一个全局的配置文件 ， 配置文件名称是固定的

application.properties。语法结构 ：key=value

application.yml。语法结构 ：key：空格 value

配置文件的作用 ：修改SpringBoot自动配置的默认值，因为SpringBoot在底层都给我们自动配置好了；

比如我们可以在配置文件中修改Tomcat 默认启动的端口号！测试一下！ server.port=8081




-------------------------------
yaml概述
YAML是 "YAML Ain't a Markup Language" （YAML不是一种标记语言）的递归缩写。在开发的这种语言时，YAML 的意思其实是："Yet Another Markup Language"（仍是一种标记语言）

这种语言以数据作为中心，而不是以标记语言为重点！

以前的配置文件，大多数都是使用xml来配置；比如一个简单的端口配置，我们来对比下yaml和xml

传统xml配置：
<server>
    <port>8081<port>
</server>
yaml配置：
server：
  prot: 8080




-------------------------------
yaml基础语法
说明：语法要求严格！

1、空格不能省略
2、以缩进来控制层级关系，只要是左边对齐的一列数据都是同一个层级的。
3、属性和值的大小写都是十分敏感的。
 

字面量：普通的值  [ 数字，布尔值，字符串  ]

字面量直接写在后面就可以,字符串默认不用加上双引号或者单引号；
k: v


注意：
""双引号，不会转义字符串里面的特殊字符,特殊字符会作为本身想表示的意思；
比如 ：name: "kuang \n shen"   输出 ：kuang  换行   shen

'' 单引号，会转义特殊字符 ， 特殊字符最终会变成和普通字符一样输出
比如 ：name: ‘kuang \n shen’   输出 ：kuang  \n   shen

 
对象、Map（键值对）

k:
	v1:
	v2:
在下一行来写对象的属性和值得关系，注意缩进；比如：
student:
    name: qinjiang
    age: 3
	
行内写法
student: {name: qinjiang,age: 3}	



数组（ List、set ）

用 - 值表示数组中的一个元素,比如：
pets:
 - cat
 - dog
 - pig
 
行内写法
pets: [cat,dog,pig]

修改SpringBoot的默认端口号
配置文件中添加，端口号的参数，就可以切换端口；
server:
  port: 8082





















-----------------------------------------------------------------------------------------------------------------------------------------------------------
springboot 依赖管理




父项目做依赖管理


依赖管理    
<parent>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-parent</artifactId>
	<version>2.3.4.RELEASE</version>
</parent>


他的父项目
<parent>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-dependencies</artifactId>
	<version>2.3.4.RELEASE</version>
</parent>

几乎声明了所有开发中常用的依赖的版本号,自动版本仲裁机制



开发导入starter场景启动器

1、见到很多 spring-boot-starter-* ： *就某种场景
2、只要引入starter，这个场景的所有常规需要的依赖我们都自动引入
3、SpringBoot所有支持的场景
https://docs.spring.io/spring-boot/docs/current/reference/html/using-spring-boot.html#using-boot-starter
4、见到的  *-spring-boot-starter： 第三方为我们提供的简化开发的场景启动器。
5、所有场景启动器最底层的依赖
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter</artifactId>
  <version>2.3.4.RELEASE</version>
</dependency>



无需关注版本号，自动版本仲裁

1、引入依赖默认都可以不写版本
2、引入非版本仲裁的jar，要写版本号。


可以修改默认版本号

1、查看spring-boot-dependencies里面规定当前依赖的版本 用的 key。
2、在当前项目里面重写配置
<properties>
	<mysql.version>5.1.43</mysql.version>
</properties>







自动配置
自动配好Tomcat
引入Tomcat依赖。
配置Tomcat


<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-tomcat</artifactId>
  <version>2.3.4.RELEASE</version>
  <scope>compile</scope>
</dependency>



● 自动配好SpringMVC
  ○ 引入SpringMVC全套组件
  ○ 自动配好SpringMVC常用组件（功能）
● 自动配好Web常见功能，如：字符编码问题
  ○ SpringBoot帮我们配置好了所有web开发的常见场景
● 默认的包结构
  ○ 主程序所在包及其下面的所有子包里面的组件都会被默认扫描进来
  ○ 无需以前的包扫描配置
  ○ 想要改变扫描路径，@SpringBootApplication(scanBasePackages="com.zhaoxi")或者@ComponentScan 指定扫描路径



@SpringBootApplication
等同于
@SpringBootConfiguration
@EnableAutoConfiguration
@ComponentScan("com.zhaoxi.boot")




● 各种配置拥有默认值
  ○ 默认配置最终都是映射到某个类上，如：MultipartProperties
  ○ 配置文件的值最终会绑定每个类上，这个类会在容器中创建对象
● 按需加载所有自动配置项
  ○ 非常多的starter
  ○ 引入了哪些场景这个场景的自动配置才会开启
  ○ SpringBoot所有的自动配置功能都在 spring-boot-autoconfigure 包里面
  ○ 
● ......




springApplication.run()有返回值，返回了ioc容器。


主程序所在包及其下面的所有子包里面的组件都会被默认扫描进来





-----------------------------------------------------------------------------------------------------------------------------------------------------------
容器功能



-------------------------------------------------------
springboot怎样给容器中添加组件




------------------------------
1、@Configuration
● 基本使用
● Full模式与Lite模式
  ○ 示例
  ○ 最佳实战
    ■ 配置 类组件之间无依赖关系用Lite模式加速容器启动过程，减少判断
    ■ 配置类组件之间有依赖关系，方法会被调用得到之前单实例组件，用Full模式

@Configuration  //告诉springboot 这是一个配置类，相当于之前的spring配置文件


/**
 * 1、配置类里面使用@Bean标注在方法上给容器注册组件，默认也是单实例的
 * 2、标注@Configuration的配置类本身 也是容器中的组件
 * 3、配置类@Configuration注解的属性 proxyBeanMethods 代理bean的方法
 * Full(proxyBeanMethods = true)、【保证每个@Bean方法被调用多少次返回的组件都是单实例的】
 * Lite(proxyBeanMethods = false)【每个@Bean方法被调用多少次返回的组件都是新创建的】
 * 组件依赖必须使用Full模式默认。其他默认是否Lite模式
 */
@Configuration  //告诉springboot 这是一个配置类，相当于之前的spring配置文件
public class MyConfig {


    @Bean  // 给容器中添加组件，以方法名作为组件的id，返回类型就是组件类型，返回的值就是组件在容器中的实例。
    public User user1() {
        return new User("zhangsan", 12);
    }

    @Bean("tom")  // 可以自定义名字，不使用方法名作为id。
    public Pet tomcat() {
        return new Pet("tomcat");
    }

}

Full(proxyBeanMethods = true):外部无论对配置类中的这个组件注册方法调用多少次获取的都是之前注册容器中的单实例对象

如果@Configuration(proxyBeanMethods = true)代理对象调用方法。SpringBoot总会检查这个组件是否在容器中有。消耗时间。








------------------------------
2、@Component、@Controller、@Service、@Repository

只要在主类同级包及其子包下标注了这些注解的类，也会注册在容器中。








------------------------------
3、@Import
写在一个容器中的组件类上就行。可以是@Configuration，也可以是@controller，@Service，@Component


@Import({User.class,DBHelper.class})
功能：给容器中自动创建出这两个类型的组件。默认组件的名字是全类名





@Import 高级用法： https://www.bilibili.com/video/BV1gW411W7wy?p=8






------------------------------
4、@Conditional
条件装配：满足Conditional指定的条件，则进行组件注入

还有一些其派生注解。



@ConditionalOnMissingBean(Goods.class)
@Bean
public Cat cat1() {
	return new Cat("aa");
}


只有当容器中没有Goods类型的组件时才会添加cat1到容器中。



@ConditionalOnBean(Goods.class)
@Configuration
public class MyConfigTwo {

    @Bean
    public Cat cat1() {
        return new Cat("aa");
    }

}

标注在类上时，对类中所有方法起作用。
只有容器中包含了Goods类型的组件时，才会添加组件。




等等......










------------------------------------------------------------------------------------------------------------------------

原生配置文件引入


1、@ImportResource

@ImportResource("classpath:beans.xml")
写在一个容器中的组件类上就行。可以是@Configuration，也可以是@controller，@Service，@Component。。


<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">


    <bean class="com.zhaoxi.springboot.helloworld.bean.Dog" id="fileDog"></bean>

</beans>

@ImportResource("classpath:beans.xml")
@Configuration
public class MyConfigTwo {

    @Bean
    public Cat cat1() {
        return new Cat("aa");
    }

}











------------------------------------------------------------------------------------------------------------------------
配置绑定 

如何使用Java读取到properties文件中的内容，并且把它封装到JavaBean中，以供随时使用；



1、@ConfigurationProperties  +  @Component
必须把该类添加到组件中才可以生效

/**
 * 只有在容器中的组件，才会拥有SpringBoot提供的强大功能
 */
@Component
@ConfigurationProperties(prefix = "mycar")
public class Car {

    private String brand;
    private Integer price;

    public String getBrand() {
        return brand;
    }

    public void setBrand(String brand) {
        this.brand = brand;
    }

    public Integer getPrice() {
        return price;
    }

    public void setPrice(Integer price) {
        this.price = price;
    }

    @Override
    public String toString() {
        return "Car{" +
                "brand='" + brand + '\'' +
                ", price=" + price +
                '}';
    }
}


application.yml
mycar:
  brand: zhaoxi
  price: 10000









2、@EnableConfigurationProperties + @ConfigurationProperties


@EnableConfigurationProperties需要写在配置类上。 开启属性配置绑定功能。把类自动注册到容器中。

@EnableConfigurationProperties(Car.class)   开启Car类的配置绑定功能，把这个Car类注册到容器中。
@Configuration
public class MyConfigTwo {

}


@ConfigurationProperties(prefix = "mycar")
public class Car {

    private String brand;
    private Integer price;

    public String getBrand() {
        return brand;
    }

    public void setBrand(String brand) {
        this.brand = brand;
    }

    public Integer getPrice() {
        return price;
    }

    public void setPrice(Integer price) {
        this.price = price;
    }

    @Override
    public String toString() {
        return "Car{" + "brand='" + brand + '\'' + ", price=" + price + '}';
    }
}

application.yml
mycar:
  brand: zhaoxi
  price: 10000




















------------------------------------------------------------------------------------------------------------------------
自动配置原理入门



引导加载自动配置类


按需开启自动配置项
虽然我们127个场景的所有自动配置启动的时候默认全部加载。xxxxAutoConfiguration
按照条件装配规则（@Conditional），最终会按需配置。






总结：
● SpringBoot先加载所有的自动配置类  xxxxxAutoConfiguration
● 每个自动配置类按照条件进行生效，默认都会绑定配置文件指定的值。xxxxProperties里面拿。xxxProperties和配置文件进行了绑定
● 生效的配置类就会给容器中装配很多组件
● 只要容器中有这些组件，相当于这些功能就有了
● 定制化配置
  ○ 用户直接自己@Bean替换底层的组件
  ○ 用户去看这个组件是获取的配置文件什么值就去修改。
xxxxxAutoConfiguration ---> 组件  ---> xxxxProperties里面拿值  ----> application.properties








-------------------------------------------------------------------------------------------------------------------------------------
最佳实践
● 引入场景依赖
  ○ https://docs.spring.io/spring-boot/docs/current/reference/html/using-spring-boot.html#using-boot-starter
● 查看自动配置了哪些（选做）
  ○ 自己分析，引入场景对应的自动配置一般都生效了
  ○ 配置文件中debug=true开启自动配置报告。Negative（不生效）\Positive（生效）
● 是否需要修改
  ○ 参照文档修改配置项
    ■ https://docs.spring.io/spring-boot/docs/current/reference/html/appendix-application-properties.html#common-application-properties
    ■ 自己分析。xxxxProperties绑定了配置文件的哪些。
  ○ 自定义加入或者替换组件
    ■ @Bean、@Component。。。
  ○ 自定义器  XXXXXCustomizer；































-------------------------------------------------------------------------------------------------------------------------------------
开发小技巧



--------------------------------------------
1、Lombok
简化JavaBean开发


先引入依赖：
<dependency>
	<groupId>org.projectlombok</groupId>
	<artifactId>lombok</artifactId>
</dependency>

然后，idea中搜索安装lombok插件


@Data注解生成get，set方法。
@ToString生成tostring方法
@NoArgsConstructor生成无参构造器
@AllArgsConstructor生成全参数的构造器


@Slf4j注解可以直接使用log对象进行日志输出。


===============================简化JavaBean开发===================================
@NoArgsConstructor
@AllArgsConstructor
@Data
@ToString
@EqualsAndHashCode
public class User {

    private String name;
    private Integer age;

    private Pet pet;

    public User(String name,Integer age){
        this.name = name;
        this.age = age;
    }


}



================================简化日志开发===================================
@Slf4j
@RestController
public class HelloController {
    @RequestMapping("/hello")
    public String handle01(@RequestParam("name") String name){
        
        log.info("请求进来了....");
        
        return "Hello, Spring Boot 2!"+"你好："+name;
    }
}






--------------------------------------------
2、spring Initailizr

使用idea创建springboot项目。





--------------------------------------------
3、dev-tools
<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-devtools</artifactId>
	<optional>true</optional>
</dependency>


项目或者页面修改以后：Ctrl+F9 就可以实时生效。（没啥用，相当于重启了）























------------------------------------------------------------------------------------------------------------------------------------------------------------------------

配置文件

文件类型

------------------------
1.1、properties
同以前的properties用法





------------------------
1.2、yaml
YAML 是 "YAML Ain't Markup Language"（YAML 不是一种标记语言）的递归缩写。在开发的这种语言时，YAML 的意思其实是："Yet Another Markup Language"（仍是一种标记语言）。 
非常适合用来做以数据为中心的配置文件

基本语法
● key: value；kv之间有空格
● 大小写敏感
● 使用缩进表示层级关系
● 缩进不允许使用tab，只允许空格。(开发时使用也没啥影响)
● 缩进的空格数不重要，只要相同层级的元素左对齐即可
● '#'表示注释
● 字符串无需加引号，如果要加，''与""表示字符串内容 会被 转义/不转义



数据类型


字面量：单个的、不可再分的值。date、boolean、string、number、null
写法：   k: v


对象：键值对的集合。map、hash、set、object 
行内写法：  k: {k1:v1,k2:v2,k3:v3}
#或
k: 
  k1: v1
  k2: v2
  k3: v3


数组：一组按次序排列的值。array、list、queue

行内写法：  k: [v1,v2,v3]
#或者
k:
 - v1
 - v2
 - v3



示例
@Data
public class Person {
	
	private String userName;
	private Boolean boss;
	private Date birth;
	private Integer age;
	private Pet pet;
	private String[] interests;
	private List<String> animal;
	private Map<String, Object> score;
	private Set<Double> salarys;
	private Map<String, List<Pet>> allPets;
}

@Data
public class Pet {
	private String name;
	private Double weight;
}


# yaml表示以上对象
person:
  userName: zhangsan
  boss: false
  birth: 2019/12/12 20:12:33
  age: 18
  pet: 
    name: tomcat
    weight: 23.4
  interests: [篮球,游泳]
  animal: 
    - jerry
    - mario
  score:
    english: 
      first: 30
      second: 40
      third: 50
    math: [131,140,148]
    chinese: {first: 128,second: 136}
  salarys: [3999,4999.98,5999.99]
  allPets:
    sick:
      - {name: tom}
      - {name: jerry,weight: 47}
    health: [{name: mario,weight: 47}]








配置提示
自定义的类和配置文件绑定一般没有提示。
引入该依赖，会有提示
打包的时候排除掉该依赖，因为对代码没啥用，还会占空间。加载的时候还会费时间。

<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-configuration-processor</artifactId>
	<optional>true</optional>
</dependency>

<build>
	<plugins>
		<plugin>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-maven-plugin</artifactId>
			<configuration>
				<excludes>
					<exclude>
						<groupId>org.springframework.boot</groupId>
						<artifactId>spring-boot-configuration-processor</artifactId>
					</exclude>
				</excludes>
			</configuration>
		</plugin>
	</plugins>
</build>























------------------------------------------------------------------------------------------------------------------------------------------------------------------------

web开发




---------------------------------------
静态资源访问


静态资源目录
默认情况下，Spring Boot从classpath中的 /static（或 /public 或 /resources 或 /META-INF/resources）目录或 ServletContext 的root中提供静态内容。 
访问 ： 当前项目根路径/ + 静态资源名 

原理： 静态映射/**。
请求进来，先去找Controller看能不能处理。不能处理的所有请求又都交给静态资源处理器。静态资源也找不到则响应404页面


改变默认的静态资源路径
spring:
  resources:
    static-locations: [classpath:/haha/]

放在类路径下的haha路径下的静态资源才可访问


静态资源访问前缀
默认无前缀
spring:
  mvc:
    static-path-pattern: /res/**

当前项目 + static-path-pattern + 静态资源名 = 静态资源文件夹下找









除了前面提到的 “标准” 静态资源位置外，还为 Webjars内容 提供了一个特殊情况。 
默认情况下，任何路径为 /webjars/** 的资源，如果是以Webjars格式打包的，将从jar文件中提供。 

路径可以通过 spring.mvc.webjars-path-pattern 属性来定制。


自动映射 /webjars/**

<dependency>
	<groupId>org.webjars</groupId>
	<artifactId>jquery</artifactId>
	<version>3.5.1</version>
</dependency>
访问地址：http://localhost:8080/webjars/jquery/3.5.1/jquery.js   后面地址要按照依赖里面的包路径








欢迎页支持
● 静态资源路径下  index.html
  ○ 可以配置静态资源路径
  ○ 但是不可以配置静态资源的访问前缀。否则导致 index.html不能被默认访问

如果静态资源路径下没有index.html，则会去模板文件中找

spring:
#  mvc:
#    static-path-pattern: /res/**   这个会导致welcome page功能失效

  resources:
    static-locations: [classpath:/haha/]


controller能处理/index





自定义 Favicon


favicon.ico 放在静态资源目录下即可。

spring:
#  mvc:
#    static-path-pattern: /res/**   这个会导致 Favicon 功能失效






静态资源配置原理

SpringBoot启动默认加载  xxxAutoConfiguration 类（自动配置类）
SpringMVC功能的自动配置类 WebMvcAutoConfiguration，生效





一个配置类只有一个有参构造器时，有参构造器所有参数的值都会默认从容器中确定

spring:
  resources:
    add-mappings: false   禁用所有静态资源规则






---------------------------------------

请求参数处理



请求映射
1、rest使用与原理
● @xxxMapping；
● Rest风格支持（使用HTTP请求方式动词来表示对资源的操作）
  ○ 以前：/getUser   获取用户     /deleteUser 删除用户    /editUser  修改用户       /saveUser 保存用户
  ○ 现在： /user    GET-获取用户    DELETE-删除用户     PUT-修改用户      POST-保存用户
  ○ 核心Filter；HiddenHttpMethodFilter
    ■ 用法： 表单method=post，隐藏域 _method=put
    ■ SpringBoot中手动开启
  ○ 扩展：如何把_method 这个名字换成我们自己喜欢的。



springboot自己配置了。要spring.mvc.hiddenmethod.filter.enabled = true 开启才生效.
但是如果自己配置了,springboot就不会再配置了.

@Bean
@ConditionalOnMissingBean(HiddenHttpMethodFilter.class)
@ConditionalOnProperty(prefix = "spring.mvc.hiddenmethod.filter", name = "enabled", matchIfMissing = false)
public OrderedHiddenHttpMethodFilter hiddenHttpMethodFilter() {
	return new OrderedHiddenHttpMethodFilter();
}


//自定义filter
@Bean
public HiddenHttpMethodFilter hiddenHttpMethodFilter(){
	HiddenHttpMethodFilter methodFilter = new HiddenHttpMethodFilter();
	methodFilter.setMethodParam("_m");
	return methodFilter;
}

Rest原理（表单提交要使用REST的时候）
● 表单提交会带上_method=PUT
● 请求过来被HiddenHttpMethodFilter拦截
  ○ 请求是否正常，并且是POST
    ■ 获取到_method的值。
    ■ 兼容以下请求；PUT.DELETE.PATCH
    ■ 原生request（post），包装模式requesWrapper重写了getMethod方法，返回的是传入的值。
    ■ 过滤器链放行的时候用wrapper。以后的方法调用getMethod是调用requesWrapper的。

Rest使用客户端工具，
● 如PostMan直接发送Put、delete等方式请求，无需Filter。


spring:
  mvc:
    hiddenmethod:
      filter:
        enabled: true   #开启页面表单的Rest功能











---------------------------------------
请求映射原理

springboot所有请求都会去找DispatcherServlet

SpringMVC功能分析都从 org.springframework.web.servlet.DispatcherServlet -> doDispatch（）


RequestMappingHandlerMapping：保存了所有@RequestMapping 和handler的映射规则。


所有的请求映射都在HandlerMapping中。

● SpringBoot自动配置欢迎页的 WelcomePageHandlerMapping 。访问 /能访问到index.html；
● SpringBoot自动配置了默认 的 RequestMappingHandlerMapping
● 请求进来，挨个尝试所有的HandlerMapping看是否有请求信息。
  ○ 如果有就找到这个请求对应的handler
  ○ 如果没有就是下一个 HandlerMapping
● 我们需要一些自定义的映射处理，我们也可以自己给容器中放HandlerMapping。自定义 HandlerMapping


protected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception {
	if (this.handlerMappings != null) {
		for (HandlerMapping mapping : this.handlerMappings) {
			HandlerExecutionChain handler = mapping.getHandler(request);
			if (handler != null) {
				return handler;
			}
		}
	}
	return null;
}













------------------------------------------------------------------------------

普通参数与基本注解
1.1、注解：
@PathVariable、@RequestHeader、@ModelAttribute、@RequestParam、@MatrixVariable、@CookieValue、@RequestBody

@RequestAttribute 获取request域属性.
@MatrixVariable  矩阵变量 （/cars/sell;low=34;brand=byd,audi,yd）

springboot 默认是禁用了矩阵变量的功能的。需要手动开启。
原理：对于路径的处理，springboot使用了UrlPathHelper进行解析。removeSemicolonContent属性是支持矩阵变量的。



需要自定义。
如果你想保留那些Spring Boot MVC定制，并进行更多的 MVC定制（Interceptor、Formatter、视图控制器和其他功能），
你可以添加你自己的 @Configuration 类，类型为 WebMvcConfigurer ，不含 @EnableWebMvc。
不用@EnableWebMvc注解。使用 @Configuration + WebMvcConfigurer 自定义规则



@Configuration(proxyBeanMethods = false)
public class MyConfig implements WebMvcConfigurer {

    @Override
    public void configurePathMatch(PathMatchConfigurer configurer) {
        UrlPathHelper urlPathHelper = new UrlPathHelper();
        urlPathHelper.setRemoveSemicolonContent(false);
        configurer.setUrlPathHelper(urlPathHelper);
    }
}




1.2、Servlet API：
WebRequest、ServletRequest、MultipartRequest、 HttpSession、javax.servlet.http.PushBuilder、Principal、InputStream、Reader、HttpMethod、Locale、TimeZone、ZoneId




1.3、复杂参数：
Map、Model（map、model里面的数据会被放在request的请求域  request.setAttribute）、Errors/BindingResult、
RedirectAttributes（ 重定向携带数据）、ServletResponse（response）、SessionStatus、UriComponentsBuilder、ServletUriComponentsBuilder

Map<String,Object> map,  Model model, HttpServletRequest request 都是可以给request域中放数据，
request.getAttribute();

Map、Model类型的参数，会返回 mavContainer.getModel（）；---> BindingAwareModelMap 是Model 也是Map
mavContainer.getModel(); 获取到值的




1.4、自定义对象参数：
可以自动类型转换与格式化，可以级联封装。

@Data
public class Person {
    
    private String userName;
    private Integer age;
    private Date birth;
    private Pet pet;
    
}

@Data
public class Pet {

    private String name;
    private String age;

}


2、POJO封装过程
● ServletModelAttributeMethodProcessor




------------------------------------------------------------------------(先了解即可，只记录了大概)---------------------------------------------------------------------------------------------
3、参数处理原理
从dispatchServlet入口开始。
● HandlerMapping中找到能处理请求的Handler（Controller.method()）
● 为当前Handler 找一个适配器 HandlerAdapter； RequestMappingHandlerAdapter
● 适配器执行目标方法并确定方法参数的每一个值





HandlerAdapter
RequestMappingHandlerAdapter 支持方法上标注@RequestMapping 


执行目标方法
mv = ha.handle(processedRequest, response, mappedHandler.getHandler());
然后进入RequestMappingHandlerAdapter
mav = invokeHandlerMethod(request, response, handlerMethod); //执行目标方法
进入invokeHandlerMethod
有参数解析器HandlerMethodArgumentResolver。确定将要执行的目标方法的每一个参数的值是什么
SpringMVC目标方法能写多少种参数类型。取决于参数解析器。
返回值处理器
SpringMVC目标方法能写多少种返回值类型。取决于返回值处理器。


● 当前解析器是否支持解析这种参数
● 支持就调用 resolveArgument



然后这一行
invocableMethod.invokeAndHandle(webRequest, mavContainer, new Object[0]);
进入invokeAndHandle方法之后：
//ServletInvocableHandlerMethod
Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs); // 真正执行控制器目标方法

然后进入invokeForRequest。
Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs);  //获取方法的参数值
protected Object[] getMethodArgumentValues(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer, Object... providedArgs) throws Exception {
        MethodParameter[] parameters = this.getMethodParameters();
        if (ObjectUtils.isEmpty(parameters)) {
            return EMPTY_ARGS;
        } else {
            Object[] args = new Object[parameters.length];

            for(int i = 0; i < parameters.length; ++i) {
                MethodParameter parameter = parameters[i];
                parameter.initParameterNameDiscovery(this.parameterNameDiscoverer);
                args[i] = findProvidedArgument(parameter, providedArgs);
                if (args[i] == null) {
                    if (!this.resolvers.supportsParameter(parameter)) {
                        throw new IllegalStateException(formatArgumentError(parameter, "No suitable resolver"));
                    }

                    try {
                        args[i] = this.resolvers.resolveArgument(parameter, mavContainer, request, this.dataBinderFactory);
                    } catch (Exception var10) {
                        if (logger.isDebugEnabled()) {
                            String exMsg = var10.getMessage();
                            if (exMsg != null && !exMsg.contains(parameter.getExecutable().toGenericString())) {
                                logger.debug(formatArgumentError(parameter, exMsg));
                            }
                        }

                        throw var10;
                    }
                }
            }

            return args;
        }
    }









自定义类型参数 封装POJO
ServletModelAttributeMethodProcessor  由这个参数处理器支持

是否为简单类型。
public static boolean isSimpleValueType(Class<?> type) {
		return (Void.class != type && void.class != type &&
				(ClassUtils.isPrimitiveOrWrapper(type) ||
				Enum.class.isAssignableFrom(type) ||
				CharSequence.class.isAssignableFrom(type) ||
				Number.class.isAssignableFrom(type) ||
				Date.class.isAssignableFrom(type) ||
				Temporal.class.isAssignableFrom(type) ||
				URI.class == type ||
				URL.class == type ||
				Locale.class == type ||
				Class.class == type));
	}


WebDataBinder binder = binderFactory.createBinder(webRequest, attribute, name);
WebDataBinder :web数据绑定器，将请求参数的值绑定到指定的JavaBean里面
WebDataBinder 利用它里面的 Converters 将请求数据转成指定的数据类型。再次封装到JavaBean中

GenericConversionService：在设置每一个值的时候，找它里面的所有converter那个可以将这个数据类型（request带来参数的字符串）转换到指定的类型（JavaBean -- Integer）
byte -- > file



@FunctionalInterface
public interface Converter<S, T>


未来我们可以给WebDataBinder里面放自己的Converter；
private static final class StringToNumber<T extends Number> implements Converter<String, T>



自定义 Converter

//1、WebMvcConfigurer定制化SpringMVC的功能
@Bean
public WebMvcConfigurer webMvcConfigurer(){
	return new WebMvcConfigurer() {

		@Override
		public void addFormatters(FormatterRegistry registry) {
			registry.addConverter(new Converter<String, Pet>() {

				@Override
				public Pet convert(String source) {
					// 啊猫,3
					if(!StringUtils.isEmpty(source)){
						Pet pet = new Pet();
						String[] split = source.split(",");
						pet.setName(split[0]);
						pet.setAge(Integer.parseInt(split[1]));
						return pet;
					}
					return null;
				}
			});
		}
	};
}




目标方法执行完成

将所有的数据都放在 ModelAndViewContainer；包含要去的页面地址View。还包含Model数据。

处理派发结果
processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);

renderMergedOutputModel(mergedModel, getRequestToExpose(request), response);





















---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
数据响应与内容协商

数据响应：1、响应页面。 2、响应数据(json，xml，xlsx...)


响应JSON。给前端自动返回json数据；
jackson.jar+@ResponseBody


<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-web</artifactId>
</dependency>
web场景自动引入了下面的json场景
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-json</artifactId>
  <version>2.3.4.RELEASE</version>
  <scope>compile</scope>
</dependency>




返回值解析器
各式各样的返回值解析器。






SpringMVC到底支持哪些返回值

ModelAndView
Model
View
ResponseEntity 
ResponseBodyEmitter
StreamingResponseBody
HttpEntity
HttpHeaders
Callable
DeferredResult
ListenableFuture
CompletionStage
WebAsyncTask
有 @ModelAttribute 且为对象类型的
@ResponseBody 注解 ---> RequestResponseBodyMethodProcessor；





------------------------------------------------------------------------------------------
返回值解析器原理

● 1、返回值处理器判断是否支持这种类型返回值 supportsReturnType
● 2、返回值处理器调用 handleReturnValue 进行处理
● 3、RequestResponseBodyMethodProcessor 可以处理返回值标了@ResponseBody 注解的。
  ○ 1.  利用 MessageConverters 进行处理 将数据写为json
    ■ 1、内容协商（浏览器默认会以请求头的方式告诉服务器他能接受什么样的内容类型）
    ■ 2、服务器最终根据自己自身的能力，决定服务器能生产出什么样内容类型的数据，
    ■ 3、SpringMVC会挨个遍历所有容器底层的 HttpMessageConverter ，看谁能处理？
      ● 1、得到MappingJackson2HttpMessageConverter可以将对象写为json
      ● 2、利用MappingJackson2HttpMessageConverter将对象转为json再写出去。




HTTPMessageConverter原理



1、MessageConverter规范
HttpMessageConverter: 看是否支持将 此 Class类型的对象，转为MediaType类型的数据。
例子：Person对象转为JSON。或者 JSON转为Person


2、默认的MessageConverter


最终 MappingJackson2HttpMessageConverter  把对象转为JSON（利用底层的jackson的objectMapper转换的）












---------------------------------------------------------------------------------------------
内容协商
根据客户端接收能力不同，返回不同媒体类型的数据。


<dependency>
	<groupId>com.fasterxml.jackson.dataformat</groupId>
	<artifactId>jackson-dataformat-xml</artifactId>
</dependency>





postman分别测试返回json和xml
只需要改变请求头中Accept字段。Http协议中规定的，告诉服务器本客户端可以接收的数据类型。

开启浏览器参数方式内容协商功能
为了方便内容协商，开启基于请求参数的内容协商功能。

spring:
    contentnegotiation:
      favor-parameter: true  #开启请求参数内容协商模式
	  
发请求： http://localhost:8080/test/person?format=json
http://localhost:8080/test/person?format=xml


确定客户端接收什么样的内容类型；
1、Parameter策略优先确定是要返回json数据（获取请求参数中的format的值）
2、最终进行内容协商返回给客户端json即可。



内容协商原理
● 1、判断当前响应头中是否已经有确定的媒体类型。MediaType
● 2、获取客户端（PostMan、浏览器）支持接收的内容类型。（获取客户端Accept请求头字段）【application/xml】
	contentNegotiationManager 内容协商管理器 默认使用基于请求头的策略。  HeaderContentNegotiationStrategy  确定客户端可以接收的内容类型 
	
● 3、遍历循环所有当前系统的 MessageConverter，看谁支持操作这个对象（Person）
● 4、找到支持操作Person的converter，把converter支持的媒体类型统计出来。
● 5、客户端需要【application/xml】。服务端能力【10种、json、xml】
● 6、进行内容协商的最佳匹配。
● 7、用支持将对象转为 最佳匹配媒体类型 的converter。调用它进行转化 。


导入了jackson处理xml的包，xml的converter就会自动进来




自定义 MessageConverter
实现多协议数据兼容。json、xml、x-guigu
0、@ResponseBody 响应数据出去 调用 RequestResponseBodyMethodProcessor 处理
1、Processor 处理方法返回值。通过 MessageConverter 处理
2、所有 MessageConverter 合起来可以支持各种媒体类型数据的操作（读、写）
3、内容协商找到最终的 messageConverter；


SpringMVC的什么功能。一个入口给容器中添加一个  WebMvcConfigurer
@Bean
public WebMvcConfigurer webMvcConfigurer(){
	return new WebMvcConfigurer() {

		@Override
		public void extendMessageConverters(List<HttpMessageConverter<?>> converters) {

		}
	}
}










该部分看源码看的我头疼，一些内容没记录。。。。














------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
视图解析与模板引擎

视图解析：SpringBoot默认不支持 JSP，需要引入第三方模板引擎技术实现页面渲染。



视图解析原理流程(看源码)
1、目标方法处理的过程中，所有数据都会被放在 ModelAndViewContainer 里面。包括数据和视图地址
2、方法的参数是一个自定义类型对象（从请求参数中确定的），把他重新放在 ModelAndViewContainer 
3、任何目标方法执行完成以后都会返回 ModelAndView（数据和视图地址）。
4、processDispatchResult  处理派发结果（页面该如何响应）
● 1、render(mv, request, response); 进行页面渲染逻辑
  ○ 1、根据方法的String返回值得到 View 对象【定义了页面的渲染逻辑】
    ■ 1、所有的视图解析器尝试是否能根据当前返回值得到View对象
    ■ 2、得到了  redirect:/main.html --> Thymeleaf new RedirectView()
    ■ 3、ContentNegotiationViewResolver 里面包含了下面所有的视图解析器，内部还是利用下面所有视图解析器得到视图对象。
    ■ 4、view.render(mv.getModelInternal(), request, response);   视图对象调用自定义的render进行页面渲染工作
      ● RedirectView 如何渲染【重定向到一个页面】
      ● 1、获取目标url地址
      ● 2、调用servlet原生的重定向response.sendRedirect(encodedURL);




视图解析：
  ○ 返回值以 forward: 开始： new InternalResourceView(forwardUrl); -->  转发request.getRequestDispatcher(path).forward(request, response); 
  ○ 返回值以 redirect: 开始： new RedirectView() --》 render就是重定向 
  ○ 返回值是普通字符串： new ThymeleafView（）---> 






自定义视图解析器+自定义视图；













----------------------------------------------------------------
模板引擎-Thymeleaf
1、thymeleaf简介
Thymeleaf is a modern server-side Java template engine for both web and standalone environments, capable of processing HTML, XML, JavaScript, CSS and even plain text.
现代化、服务端Java模板引擎


2、基本语法

1、表达式
表达式名字	语法	用途
变量取值	${...} 	获取请求域、session域、对象等值
选择变量	*{...}	获取上下文对象值
消息	#{...}	获取国际化等值
链接	@{...}	生成链接
片段表达式	~{...}	jsp:include 作用，引入公共页面片段



2、字面量
文本值: 'one text' , 'Another one!' ,…数字: 0 , 34 , 3.0 , 12.3 ,…布尔值: true , false
空值: null
变量： one，two，.... 变量不能有空格

3、文本操作
字符串拼接: +
变量替换: |The name is ${name}| 

4、数学运算
运算符: + , - , * , / , %

5、布尔运算
运算符:  and , or
一元运算: ! , not 


6、比较运算
比较: > , < , >= , <= ( gt , lt , ge , le )等式: == , != ( eq , ne ) 

7、条件运算
If-then: (if) ? (then)
If-then-else: (if) ? (then) : (else)
Default: (value) ?: (defaultvalue) 


8、特殊操作




设置属性值-th:attr



迭代
<tr th:each="prod : ${prods}">
	<td th:text="${prod.name}">Onions</td>
	<td th:text="${prod.price}">2.41</td>
	<td th:text="${prod.inStock}? #{true} : #{false}">yes</td>
</tr>



条件运算

<a href="comments.html"
th:href="@{/product/comments(prodId=${prod.id})}"
th:if="${not #lists.isEmpty(prod.comments)}">view</a>

<div th:switch="${user.role}">
  <p th:case="'admin'">User is an administrator</p>
  <p th:case="#{roles.manager}">User is a manager</p>
  <p th:case="*">User is some other thing</p>
</div>




属性优先级







----------------------------------------------------------------
thymeleaf使用


引入Starter



<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-thymeleaf</artifactId>
</dependency>



自动配置好了thymeleaf

@Configuration(proxyBeanMethods = false)
@EnableConfigurationProperties(ThymeleafProperties.class)
@ConditionalOnClass({ TemplateMode.class, SpringTemplateEngine.class })
@AutoConfigureAfter({ WebMvcAutoConfiguration.class, WebFluxAutoConfiguration.class })
public class ThymeleafAutoConfiguration { }



自动配好的策略
● 1、所有thymeleaf的配置值都在 ThymeleafProperties
● 2、配置好了 SpringTemplateEngine 
● 3、配好了 ThymeleafViewResolver 
● 4、我们只需要直接开发页面

public static final String DEFAULT_PREFIX = "classpath:/templates/";

public static final String DEFAULT_SUFFIX = ".html";  //xxx.html


页面放在templates目录下





























------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

6、拦截器

实现HandlerInterceptor 接口



public class FirstInterceptor implements HandlerInterceptor {
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        System.out.println("FirstInterceptor----------->>>>>>>>preHandle");
        return HandlerInterceptor.super.preHandle(request, response, handler);
    }

    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        System.out.println("FirstInterceptor----------->>>>>>>>postHandle");

        HandlerInterceptor.super.postHandle(request, response, handler, modelAndView);
    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        System.out.println("FirstInterceptor----------->>>>>>>>afterCompletion");

        HandlerInterceptor.super.afterCompletion(request, response, handler, ex);
    }
}


/**
 * 1、编写一个拦截器实现HandlerInterceptor接口
 * 2、拦截器注册到容器中（实现WebMvcConfigurer的addInterceptors）
 * 3、指定拦截规则【如果是拦截所有，静态资源也会被拦截】
 */
@Configuration
public class AdminWebConfig implements WebMvcConfigurer {

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(new FirstInterceptor())
                .addPathPatterns("/**")  //所有请求都被拦截包括静态资源
                .excludePathPatterns("/","/login","/css/**","/fonts/**","/images/**","/js/**"); //放行的请求
    }
}



拦截器原理
1、根据当前请求，找到HandlerExecutionChain【可以处理请求的handler以及handler的所有拦截器】
2、先来顺序执行 所有拦截器的 preHandle方法
● 1、如果当前拦截器prehandler返回为true。则执行下一个拦截器的preHandle
● 2、如果当前拦截器返回为false。直接倒序执行所有已经执行了的拦截器的  afterCompletion；
3、如果任何一个拦截器返回false。直接跳出不执行目标方法
4、所有拦截器都返回True。执行目标方法
5、倒序执行所有拦截器的postHandle方法。
6、前面的步骤有任何异常都会直接倒序触发 afterCompletion
7、页面成功渲染完成以后，也会倒序触发 afterCompletion















------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
文件上传

springboot无需任何设置，直接可用。

spring:
  servlet:
    multipart:
      max-file-size: 10MB  单个文件的最大大小
      max-request-size: 100MB  单次请求的最大大小


自动配置原理
文件上传自动配置类-MultipartAutoConfiguration-MultipartProperties
自动配置好了 StandardServletMultipartResolver   【文件上传解析器】
原理步骤
1、请求进来使用文件上传解析器判断（isMultipart）并封装（resolveMultipart，返回MultipartHttpServletRequest）文件上传请求
2、参数解析器来解析请求中的文件内容封装成MultipartFile
3、将request中文件信息封装为一个Map；MultiValueMap<String, MultipartFile> 
FileCopyUtils。实现文件流的拷贝








------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
异常处理

错误处理
1、默认规则
● 默认情况下，Spring Boot提供/error处理所有错误的映射
对于机器客户端，它将生成JSON响应，其中包含错误，HTTP状态和异常消息的详细信息。
对于浏览器客户端，响应一个“whitelabel”错误视图，以HTML格式呈现相同的数据

要自定义它，添加一个 View，解析为 error


要完全替换默认行为，你可以实现 ErrorController 并注册该类型的Bean定义，或者添加 ErrorAttributes 类型的Bean来使用现有机制但替换内容。


自定义Error页面
如果你想为一个给定的状态代码显示一个自定义的HTML错误页面，你可以在 /error 目录下添加一个文件。 
错误页面可以是静态HTML（即添加在任何一个静态资源目录下），也可以通过使用模板建立。 
文件的名称应该是准确的状态代码或一系列的掩码。

error文件夹可以在静态文件夹下，也可以在模板文件夹下

例如，/error下的4xx，5xx页面会被自动解析(404.html，5xx.html....)







2、定制错误处理逻辑
● 自定义错误页
  ○ error/404.html   error/5xx.html；有精确的错误状态码页面就匹配精确，没有就找 4xx.html；如果都没有就触发白页
  
● @ControllerAdvice+@ExceptionHandler处理全局异常；底层是 ExceptionHandlerExceptionResolver 支持的

● @ResponseStatus+自定义异常 ；底层是 ResponseStatusExceptionResolver ，把responsestatus注解的信息底层调用 response.sendError(statusCode, resolvedReason)；tomcat发送的/error

● Spring底层的异常，如 参数类型转换异常；DefaultHandlerExceptionResolver 处理框架底层的异常。
  ○ response.sendError(HttpServletResponse.SC_BAD_REQUEST, ex.getMessage()); 

自定义实现 HandlerExceptionResolver 处理异常；可以作为默认的全局异常处理规则

● ErrorViewResolver  实现自定义处理异常；
  ○ response.sendError 。error请求就会转给controller
  ○ 你的异常没有任何人能处理。tomcat底层 response.sendError。error请求就会转给controller
  ○ basicErrorController 要去的页面地址是 ErrorViewResolver  





3、异常处理自动配置原理
● ErrorMvcAutoConfiguration  自动配置异常处理规则
  ○ 容器中的组件：类型：DefaultErrorAttributes -> id：errorAttributes
    ■ public class DefaultErrorAttributes implements ErrorAttributes, HandlerExceptionResolver
    ■ DefaultErrorAttributes：定义错误页面中可以包含哪些数据。


  ○ 容器中的组件：类型：BasicErrorController --> id：basicErrorController（json+白页 适配响应）
    ■ 处理默认 /error 路径的请求；页面响应 new ModelAndView("error", model)；
    ■ 容器中有组件 View->id是error；（响应默认错误页）
    ■ 容器中放组件 BeanNameViewResolver（视图解析器）；按照返回的视图名作为组件的id去容器中找View对象。
	
	
  ○ 容器中的组件：类型：DefaultErrorViewResolver -> id：conventionErrorViewResolver
    ■ 如果发生错误，会以HTTP的状态码 作为视图页地址（viewName），找到真正的页面
    ■ error/404、5xx.html

如果想要返回页面；就会找error视图【StaticView】。(默认是一个白页)







4、异常处理步骤流程
1、执行目标方法，目标方法运行期间有任何异常都会被catch、并且标志当前请求结束；并且用 dispatchException 来封装
2、进入视图解析流程（页面渲染？） 
processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);
3、mv = processHandlerException；处理handler发生的异常，处理完成返回ModelAndView；
● 1、遍历所有的 handlerExceptionResolvers，看谁能处理当前异常【HandlerExceptionResolver处理器异常解析器】
● 2、系统默认的  异常解析器
  ○ 1、DefaultErrorAttributes先来处理异常。把异常信息保存到request域，然后返回null；
  ○ 2、默认没有任何人能处理异常，所以异常会被抛出
    ■ 1、如果没有任何人能处理最终底层就会发送 /error 请求。会被底层的BasicErrorController处理
    ■ 2、解析错误视图；遍历所有的  ErrorViewResolver  看谁能解析。
    ■ 3、默认的 DefaultErrorViewResolver ,作用是把响应状态码作为错误页的地址，error/500.html 
    ■ 4、模板引擎最终响应这个页面 error/500.html 






















------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

9、Web原生组件注入（Servlet、Filter、Listener）



1、使用Servlet API  推荐可以这种方式
@ServletComponentScan(basePackages = "com.atguigu.admin") :指定原生Servlet组件都放在那里.在配置类上标注或者在主类上标注.
@WebServlet(urlPatterns = "/my")：效果：直接响应，没有经过Spring的拦截器

@WebFilter(urlPatterns={"/css/*","/images/*"})
@WebListener



扩展：DispatchServlet 如何注册进来
● 容器中自动配置了  DispatcherServlet  属性绑定到 WebMvcProperties；对应的配置文件配置项是 spring.mvc。
● 通过 ServletRegistrationBean<DispatcherServlet> 把 DispatcherServlet  配置进来。
● 默认映射的是 / 路径。

Tomcat-Servlet；
多个Servlet都能处理到同一层路径，精确优选原则
A： /my/
B： /my/1




2、使用RegistrationBean
ServletRegistrationBean, FilterRegistrationBean, and ServletListenerRegistrationBean

@Configuration
public class MyRegistConfig {

    @Bean
    public ServletRegistrationBean myServlet(){
        MyServlet myServlet = new MyServlet();

        return new ServletRegistrationBean(myServlet,"/my","/my02");
    }


    @Bean
    public FilterRegistrationBean myFilter(){

        MyFilter myFilter = new MyFilter();
//        return new FilterRegistrationBean(myFilter,myServlet());   // 拦截指定的servlet.  myServlet()
        FilterRegistrationBean filterRegistrationBean = new FilterRegistrationBean(myFilter);
        filterRegistrationBean.setUrlPatterns(Arrays.asList("/my","/css/*"));
        return filterRegistrationBean;
    }

    @Bean
    public ServletListenerRegistrationBean myListener(){
        MySwervletContextListener mySwervletContextListener = new MySwervletContextListener();
        return new ServletListenerRegistrationBean(mySwervletContextListener);
    }
}















------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

10、嵌入式Servlet容器


切换嵌入式Servlet容器
● 默认支持的webServer
  ○ Tomcat, Jetty, or Undertow
  ○ ServletWebServerApplicationContext 容器启动寻找ServletWebServerFactory 并引导创建服务器

● 原理
  ○ SpringBoot应用启动发现当前是Web应用。web场景包-导入tomcat
  ○ web应用会创建一个web版的ioc容器 ServletWebServerApplicationContext 
  ○ ServletWebServerApplicationContext  启动的时候寻找 ServletWebServerFactory（Servlet 的web服务器工厂--->生产Servlet 的web服务器）  
  ○ SpringBoot底层默认有很多的WebServer工厂；TomcatServletWebServerFactory, JettyServletWebServerFactory, or UndertowServletWebServerFactory
  ○ 底层直接会有一个自动配置类。ServletWebServerFactoryAutoConfiguration
  ○ ServletWebServerFactoryAutoConfiguration导入了ServletWebServerFactoryConfiguration（配置类）
  ○ ServletWebServerFactoryConfiguration 配置类 根据动态判断系统中到底导入了那个Web服务器的包。（默认是web-starter导入tomcat包），容器中就有 TomcatServletWebServerFactory
  ○ TomcatServletWebServerFactory 创建出Tomcat服务器并启动；TomcatWebServer 的构造器拥有初始化方法initialize---this.tomcat.start();
  ○ 内嵌服务器，就是手动把启动服务器的代码调用（tomcat核心jar包存在）






切换undertow服务器

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
    <exclusions>
        <exclusion>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-tomcat</artifactId>
        </exclusion>
    </exclusions>
</dependency>

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-undertow</artifactId>
</dependency>



2、定制Servlet容器
● 实现  WebServerFactoryCustomizer<ConfigurableServletWebServerFactory> 
  ○ 把配置文件的值和ServletWebServerFactory 进行绑定
● 修改配置文件 server.xxx
● 直接自定义 ConfigurableServletWebServerFactory 

xxxxxCustomizer：定制化器，可以改变xxxx的默认规则

import org.springframework.boot.web.server.WebServerFactoryCustomizer;
import org.springframework.boot.web.servlet.server.ConfigurableServletWebServerFactory;
import org.springframework.stereotype.Component;

@Component
public class CustomizationBean implements WebServerFactoryCustomizer<ConfigurableServletWebServerFactory> {

    @Override
    public void customize(ConfigurableServletWebServerFactory server) {
        server.setPort(9000);
    }

}

















------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
定制化原理
1、定制化的常见方式 

● 修改配置文件；
● xxxxxCustomizer；
● 编写自定义的配置类   xxxConfiguration；+ @Bean替换、增加容器中默认组件；视图解析器 
● Web应用 编写一个配置类实现 WebMvcConfigurer 即可定制化web功能；+ @Bean给容器中再扩展一些组件
@Configuration
public class AdminWebConfig implements WebMvcConfigurer

● @EnableWebMvc + WebMvcConfigurer —— @Bean  可以全面接管SpringMVC，所有规则全部自己重新配置； 实现定制和扩展功能
  ○ 原理
  ○ 1、WebMvcAutoConfiguration  默认的SpringMVC的自动配置功能类。静态资源、欢迎页.....
  ○ 2、一旦使用 @EnableWebMvc 、。会 @Import(DelegatingWebMvcConfiguration.class)
  ○ 3、DelegatingWebMvcConfiguration 的 作用，只保证SpringMVC最基本的使用
    ■ 把所有系统中的 WebMvcConfigurer 拿过来。所有功能的定制都是这些 WebMvcConfigurer  合起来一起生效
    ■ 自动配置了一些非常底层的组件。RequestMappingHandlerMapping、这些组件依赖的组件都是从容器中获取
    ■ public class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport
  ○ 4、WebMvcAutoConfiguration 里面的配置要能生效 必须  @ConditionalOnMissingBean(WebMvcConfigurationSupport.class)
  ○ 5、@EnableWebMvc  导致了 WebMvcAutoConfiguration  没有生效。

2、原理分析套路
场景starter - xxxxAutoConfiguration - 导入xxx组件 - 绑定xxxProperties -- 绑



























------------------------------------------------------------------------------------------------------------------------------------------------------------------------

数据访问




-----------------------------------------------------------------------------------
1、SQL


1、数据源的自动配置-HikariDataSource

1、导入JDBC场景

<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-data-jdbc</artifactId>
</dependency>


数据库驱动？
为什么导入JDBC场景，官方不导入驱动？官方不知道我们接下要操作什么数据库。
数据库版本和驱动版本对应
springboot默认版本：<mysql.version>8.0.22</mysql.version>

<dependency>
	<groupId>mysql</groupId>
	<artifactId>mysql-connector-java</artifactId>
<!--<version>5.1.49</version>-->
</dependency>
想要修改版本
1、直接依赖引入具体版本（maven的就近依赖原则）
2、重新声明版本（maven的属性的就近优先原则）
<properties>
	<mysql.version>5.1.49</mysql.version>
</properties>








2、分析自动配置

1、自动配置的类
● DataSourceAutoConfiguration ： 数据源的自动配置
  ○ 修改数据源相关的配置：spring.datasource
  ○ 数据库连接池的配置，是自己容器中没有DataSource才自动配置的
  ○ 底层配置好的连接池是：HikariDataSource

@Configuration(proxyBeanMethods = false)
@Conditional(PooledDataSourceCondition.class)
@ConditionalOnMissingBean({ DataSource.class, XADataSource.class })
@Import({ DataSourceConfiguration.Hikari.class, DataSourceConfiguration.Tomcat.class,
		DataSourceConfiguration.Dbcp2.class, DataSourceConfiguration.OracleUcp.class,
		DataSourceConfiguration.Generic.class, DataSourceJmxConfiguration.class })
protected static class PooledDataSourceConfiguration



● DataSourceTransactionManagerAutoConfiguration： 事务管理器的自动配置
● JdbcTemplateAutoConfiguration： JdbcTemplate的自动配置，可以来对数据库进行crud
  ○ 可以修改这个配置项@ConfigurationProperties(prefix = "spring.jdbc") 来修改JdbcTemplate
  ○ @Bean  @Primary    JdbcTemplate；容器中有这个组件
● JndiDataSourceAutoConfiguration： jndi的自动配置
● XADataSourceAutoConfiguration： 分布式事务相关的







3、修改配置项


spring:
  datasource:
    url: jdbc:mysql://localhost:3306/db_account
    username: root
    password: 123456
    driver-class-name: com.mysql.jdbc.Driver





4、测试

@Slf4j
@SpringBootTest
class Boot05WebAdminApplicationTests {

    @Autowired
    JdbcTemplate jdbcTemplate;


    @Test
    void contextLoads() {

//        jdbcTemplate.queryForObject("select * from account_tbl")
//        jdbcTemplate.queryForList("select * from account_tbl",)
        Long aLong = jdbcTemplate.queryForObject("select count(*) from account_tbl", Long.class);
        log.info("记录总数：{}",aLong);
    }

}















-----------------------------------------------------------------------------------

2、使用Druid数据源
1、druid官方github地址
https://github.com/alibaba/druid

整合第三方技术的两种方式
● 自定义
● 找starter


-----------------------------------------
自定义方式

1、创建数据源
<dependency>
	<groupId>com.alibaba</groupId>
	<artifactId>druid</artifactId>
	<version>1.1.17</version>
</dependency>

<bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource" destroy-method="close">
		<property name="url" value="${jdbc.url}" />
		<property name="username" value="${jdbc.username}" />
		<property name="password" value="${jdbc.password}" />
		<property name="maxActive" value="20" />
		<property name="initialSize" value="1" />
		<property name="maxWait" value="60000" />
		<property name="minIdle" value="1" />
		<property name="timeBetweenEvictionRunsMillis" value="60000" />
		<property name="minEvictableIdleTimeMillis" value="300000" />
		<property name="testWhileIdle" value="true" />
		<property name="testOnBorrow" value="false" />
		<property name="testOnReturn" value="false" />
		<property name="poolPreparedStatements" value="true" />
		<property name="maxOpenPreparedStatements" value="20" />
</bean>



2、StatViewServlet
StatViewServlet的用途包括：
● 提供监控信息展示的html页面
● 提供监控信息的JSON API

<servlet>
	<servlet-name>DruidStatView</servlet-name>
	<servlet-class>com.alibaba.druid.support.http.StatViewServlet</servlet-class>
</servlet>
<servlet-mapping>
	<servlet-name>DruidStatView</servlet-name>
	<url-pattern>/druid/*</url-pattern>
</servlet-mapping>



3、StatFilter
用于统计监控信息；如SQL监控、URI监控

需要给数据源中配置如下属性；可以允许多个filter，多个用，分割；如：

<property name="filters" value="stat,slf4j" />

系统中所有filter：
别名	Filter类名
default	com.alibaba.druid.filter.stat.StatFilter
stat	com.alibaba.druid.filter.stat.StatFilter
mergeStat	com.alibaba.druid.filter.stat.MergeStatFilter
encoding	com.alibaba.druid.filter.encoding.EncodingConvertFilter
log4j	com.alibaba.druid.filter.logging.Log4jFilter
log4j2	com.alibaba.druid.filter.logging.Log4j2Filter
slf4j	com.alibaba.druid.filter.logging.Slf4jLogFilter
commonlogging	com.alibaba.druid.filter.logging.CommonsLogFilter


慢SQL记录配置
<bean id="stat-filter" class="com.alibaba.druid.filter.stat.StatFilter">
    <property name="slowSqlMillis" value="10000" />
    <property name="logSlowSql" value="true" />
</bean>

使用 slowSqlMillis 定义慢SQL的时长






-----------------------------------------
使用官方starter方式
1、引入druid-starter

<dependency>
	<groupId>com.alibaba</groupId>
	<artifactId>druid-spring-boot-starter</artifactId>
	<version>1.1.17</version>
</dependency>



2、分析自动配置
● 扩展配置项 spring.datasource.druid
● DruidSpringAopConfiguration.class,   监控SpringBean的；配置项：spring.datasource.druid.aop-patterns
● DruidStatViewServletConfiguration.class, 监控页的配置：spring.datasource.druid.stat-view-servlet；默认开启
●  DruidWebStatFilterConfiguration.class, web监控配置；spring.datasource.druid.web-stat-filter；默认开启
● DruidFilterConfiguration.class}) 所有Druid自己filter的配置


private static final String FILTER_STAT_PREFIX = "spring.datasource.druid.filter.stat";
private static final String FILTER_CONFIG_PREFIX = "spring.datasource.druid.filter.config";
private static final String FILTER_ENCODING_PREFIX = "spring.datasource.druid.filter.encoding";
private static final String FILTER_SLF4J_PREFIX = "spring.datasource.druid.filter.slf4j";
private static final String FILTER_LOG4J_PREFIX = "spring.datasource.druid.filter.log4j";
private static final String FILTER_LOG4J2_PREFIX = "spring.datasource.druid.filter.log4j2";
private static final String FILTER_COMMONS_LOG_PREFIX = "spring.datasource.druid.filter.commons-log";
private static final String FILTER_WALL_PREFIX = "spring.datasource.druid.filter.wall";



3、配置示例

spring:
  datasource:
    url: jdbc:mysql://localhost:3306/db_account
    username: root
    password: 123456
    driver-class-name: com.mysql.jdbc.Driver

    druid:
      aop-patterns: com.atguigu.admin.*  #监控SpringBean
      filters: stat,wall     # 底层开启功能，stat（sql监控），wall（防火墙）

      stat-view-servlet:   # 配置监控页功能
        enabled: true
        login-username: admin
        login-password: admin
        resetEnable: false

      web-stat-filter:  # 监控web
        enabled: true
        urlPattern: /*
        exclusions: '*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*'


      filter:
        stat:    # 对上面filters里面的stat的详细配置
          slow-sql-millis: 1000
          logSlowSql: true
          enabled: true
        wall:
          enabled: true
          config:
            drop-table-allow: false



SpringBoot配置示例
https://github.com/alibaba/druid/tree/master/druid-spring-boot-starter

配置项列表https://github.com/alibaba/druid/wiki/DruidDataSource%E9%85%8D%E7%BD%AE%E5%B1%9E%E6%80%A7%E5%88%97%E8%A1%A8











-----------------------------------------------------------------------------------


整合MyBatis操作
https://github.com/mybatis

starter
SpringBoot官方的Starter：spring-boot-starter-*
第三方的： *-spring-boot-starter



<dependency>
	<groupId>org.mybatis.spring.boot</groupId>
	<artifactId>mybatis-spring-boot-starter</artifactId>
	<version>2.1.4</version>
</dependency>



---------------------------------------------------------------------------------------
配置模式

● 全局配置文件
● SqlSessionFactory: 自动配置好了
● SqlSession：自动配置了 SqlSessionTemplate 组合了SqlSession
● @Import(AutoConfiguredMapperScannerRegistrar.class）Mapper： 只要我们写的操作MyBatis的接口标注了 @Mapper 就会被自动扫描进来



@EnableConfigurationProperties(MybatisProperties.class) ： MyBatis配置项绑定类。
@AutoConfigureAfter({ DataSourceAutoConfiguration.class, MybatisLanguageDriverAutoConfiguration.class })
public class MybatisAutoConfiguration{}

@ConfigurationProperties(prefix = "mybatis")
public class MybatisProperties



可以修改配置文件中 mybatis 开始的所有；

# 配置mybatis规则
mybatis:
  config-location: classpath:mybatis/mybatis-config.xml  #全局配置文件位置
  mapper-locations: classpath:mybatis/mapper/*.xml  #sql映射文件位置



Mapper接口--->绑定Xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.atguigu.admin.mapper.AccountMapper">
<!--    public Account getAcct(Long id); -->
    <select id="getAcct" resultType="com.atguigu.admin.bean.Account">
        select * from  account_tbl where  id=#{id}
    </select>
</mapper>



配置 private Configuration configuration; mybatis.configuration下面的所有，就是相当于改mybatis全局配置文件中的值



# 配置mybatis规则
mybatis:
#  config-location: classpath:mybatis/mybatis-config.xml
  mapper-locations: classpath:mybatis/mapper/*.xml
  configuration:
    map-underscore-to-camel-case: true
    
可以不写全局配置文件，所有全局配置文件的配置都放在configuration配置项中即可。(configuration配置项与全局配置文件不能同时存在)




流程：
● 导入mybatis官方starter
● 编写mapper接口。标注@Mapper注解
● 编写sql映射文件并绑定mapper接口
● 在application.yaml中指定Mapper配置文件的位置，以及指定全局配置文件的信息 （建议；配置在mybatis.configuration）





---------------------------------------------------------------------------------------
注解模式


@Mapper
public interface CityMapper {

    @Select("select * from city where id=#{id}")
    public City getById(Long id);

    public void insert(City city);

}






---------------------------------------------------------------------------------------
混合模式

@Mapper
public interface CityMapper {

    @Select("select * from city where id=#{id}")
    public City getById(Long id);
	
	@Insert("insert into city(name,state,country) values("aa","bb","cc")")
	@Options(useGeneratedKeys=true,keyProperty="id")
    public void insert(City city);

}



总结最佳实战：
● 引入mybatis-starter
● 配置application.yaml中，指定mapper-location位置即可
● 编写Mapper接口并标注@Mapper注解
● 简单方法直接注解方式
● 复杂方法编写mapper.xml进行绑定映射
● @MapperScan("com.atguigu.admin.mapper") 简化，其他的接口就可以不用标注@Mapper注解














------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
整合 MyBatis-Plus 完成CRUD


什么是MyBatis-Plus
MyBatis-Plus（简称 MP）是一个 MyBatis 的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。

mybatis plus 官网 。 https://baomidou.com/

建议安装 MybatisX 插件 




整合MyBatis-Plus

<dependency>
	<groupId>com.baomidou</groupId>
	<artifactId>mybatis-plus-boot-starter</artifactId>
	<version>3.4.1</version>
</dependency>


自动配置
● MybatisPlusAutoConfiguration 配置类，MybatisPlusProperties 配置项绑定。mybatis-plus：xxx 就是对mybatis-plus的定制
● SqlSessionFactory 自动配置好。底层是容器中默认的数据源
● mapperLocations 自动配置好的。有默认值。classpath*:/mapper/**/*.xml；
任意包的类路径下的所有mapper文件夹下任意路径下的所有xml都是sql映射文件。  建议以后sql映射文件，放在 mapper下
● 容器中也自动配置好了 SqlSessionTemplate
● @Mapper 标注的接口也会被自动扫描；建议直接 @MapperScan("com.atguigu.admin.mapper") 批量扫描就行


@Bean标注的方法，如果参数是一个对象，则该参数会从容器内自动确定。

优点：
●  只需要我们的Mapper继承 BaseMapper 就可以拥有crud能力



mybatis-plus继承BaseMapper后，指定的泛型类，默认表名与类名相同
表名与类名不同时。使用@TableName注解指定表明就行。


@Service
public class UserServiceImpl extends ServiceImpl<UserMapper,User> implements UserService {
}

public interface UserService extends IService<User> {
}



mybatis-plus 提供了一个在service层的接口IService，service层需要继承IService，当然实现层也要继承对应的实现类。
IService中实现了一些方法，可以直接调用。(底层还是调用的baseMapper中的方法)



CRUD功能

@GetMapping("/user/delete/{id}")
public String deleteUser(@PathVariable("id") Long id,
						 @RequestParam(value = "pn",defaultValue = "1")Integer pn,
						 RedirectAttributes ra){

	userService.removeById(id);

	ra.addAttribute("pn",pn);
	return "redirect:/dynamic_table";
}


@GetMapping("/dynamic_table")
public String dynamic_table(@RequestParam(value="pn",defaultValue = "1") Integer pn,Model model){

	//构造分页参数
	Page<User> page = new Page<>(pn, 2);
	//调用page进行分页
	Page<User> userPage = userService.page(page, null);
	

	model.addAttribute("users",userPage);

	return "table/dynamic_table";
}



使用分页需要在容器中配置注册分页插件(拦截器)
@Bean
public MybatisPlusInterceptor mybatisPlusInterceptor() {
    MybatisPlusInterceptor mybatisPlusInterceptor = new MybatisPlusInterceptor();
    PaginationInnerInterceptor paginationInnerInterceptor = new PaginationInnerInterceptor();
    mybatisPlusInterceptor.addInnerInterceptor(paginationInnerInterceptor);
    return mybatisPlusInterceptor;
}





------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
NoSQL





------------------------------------------------
1、Redis自动配置


<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>




自动配置：
● RedisAutoConfiguration 自动配置类。RedisProperties 属性类 --> spring.redis.xxx是对redis的配置
● 连接工厂是准备好的。LettuceConnectionConfiguration、JedisConnectionConfiguration
● 自动注入了RedisTemplate<Object, Object> ： xxxTemplate；
● 自动注入了StringRedisTemplate；k：v都是String
● key：value
● 底层只要我们使用 StringRedisTemplate、RedisTemplate就可以操作redis





2、RedisTemplate与Lettuce

@Test
void testRedis(){
	ValueOperations<String, String> operations = redisTemplate.opsForValue();

	operations.set("hello","world");

	String hello = operations.get("hello");
	System.out.println(hello);
}



3、切换至jedis

<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>

<!--        导入jedis-->
<dependency>
	<groupId>redis.clients</groupId>
	<artifactId>jedis</artifactId>
</dependency>




spring:
  redis:
      host: r-bp1nc7reqesxisgxpipd.redis.rds.aliyuncs.com
      port: 6379
      password: lfy:Lfy123456
      client-type: jedis
      jedis:
        pool:
          max-active: 10
























------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

7、单元测试





1、JUnit5 的变化
Spring Boot 2.2.0 版本开始引入 JUnit 5 作为单元测试默认库
作为最新版本的JUnit框架，JUnit5与之前版本的Junit框架有很大的不同。由三个不同子项目的几个不同模块组成。
JUnit 5 = JUnit Platform + JUnit Jupiter + JUnit Vintage
JUnit Platform: Junit Platform是在JVM上启动测试框架的基础，不仅支持Junit自制的测试引擎，其他测试引擎也都可以接入。
JUnit Jupiter: JUnit Jupiter提供了JUnit5的新的编程模型，是JUnit5新特性的核心。内部 包含了一个测试引擎，用于在Junit Platform上运行。
JUnit Vintage: 由于JUint已经发展多年，为了照顾老的项目，JUnit Vintage提供了兼容JUnit4.x,Junit3.x的测试引擎。


注意：
SpringBoot 2.4 以上版本移除了默认对 Vintage 的依赖。如果需要兼容junit4需要自行引入（不能使用junit4的功能 @Test）
JUnit 5’s Vintage Engine Removed from spring-boot-starter-test,如果需要继续兼容junit4需要自行引入vintage


<dependency>
    <groupId>org.junit.vintage</groupId>
    <artifactId>junit-vintage-engine</artifactId>
    <scope>test</scope>
    <exclusions>
        <exclusion>
            <groupId>org.hamcrest</groupId>
            <artifactId>hamcrest-core</artifactId>
        </exclusion>
    </exclusions>
</dependency>









----------------------------------------------------------------
想要进行测试

只需引入依赖就可进行编码

<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-test</artifactId>
  <scope>test</scope>
</dependency>



编写测试代码
@SpringBootTest
class Boot05WebAdminApplicationTests {


    @Test
    void contextLoads() {

    }
}


以前：
@SpringBootTest + @RunWith(SpringTest.class)


SpringBoot整合Junit以后。
● 编写测试方法：@Test标注（注意需要使用junit5版本的注解）
● Junit类具有Spring的功能，@Autowired、比如 @Transactional 标注测试方法，测试完成后自动回滚




JUnit5常用注解
JUnit5的注解与JUnit4的注解有所变化
https://junit.org/junit5/docs/current/user-guide/#writing-tests-annotations

● @Test :表示方法是测试方法。但是与JUnit4的@Test不同，他的职责非常单一不能声明任何属性，拓展的测试将会由Jupiter提供额外测试
● @ParameterizedTest :表示方法是参数化测试，下方会有详细介绍
● @RepeatedTest :表示方法可重复执行，下方会有详细介绍
● @DisplayName :为测试类或者测试方法设置展示名称
● @BeforeEach :表示在每个单元测试之前执行
● @AfterEach :表示在每个单元测试之后执行
● @BeforeAll :表示在所有单元测试之前执行
● @AfterAll :表示在所有单元测试之后执行
● @Tag :表示单元测试类别，类似于JUnit4中的@Categories
● @Disabled :表示测试类或测试方法不执行，类似于JUnit4中的@Ignore
● @Timeout :表示测试方法运行如果超过了指定时间将会返回错误
● @ExtendWith :为测试类或测试方法提供扩展类引用


import org.junit.jupiter.api.Test; //注意这里使用的是jupiter的Test注解！！

public class TestDemo {

  @Test
  @DisplayName("第一次测试")
  public void firstTest() {
      System.out.println("hello world");
  }





断言（assertions）
断言（assertions）是测试方法中的核心部分，用来对测试需要满足的条件进行验证。这些断言方法都是 org.junit.jupiter.api.Assertions 的静态方法。JUnit 5 内置的断言可以分成如下几个类别：
检查业务逻辑返回的数据是否合理。
所有的测试运行结束以后，会有一个详细的测试报告；



1、简单断言
用来对单个值进行简单的验证。如：
方法	说明
assertEquals	判断两个对象或两个原始类型是否相等
assertNotEquals	判断两个对象或两个原始类型是否不相等
assertSame	判断两个对象引用是否指向同一个对象
assertNotSame	判断两个对象引用是否指向不同的对象
assertTrue	判断给定的布尔值是否为 true
assertFalse	判断给定的布尔值是否为 false
assertNull	判断给定的对象引用是否为 null
assertNotNull	判断给定的对象引用是否不为 null


@Test
@DisplayName("simple assertion")
public void simple() {
     assertEquals(3, 1 + 2, "simple math");
     assertNotEquals(3, 1 + 1);

     assertNotSame(new Object(), new Object());
     Object obj = new Object();
     assertSame(obj, obj);

     assertFalse(1 > 2);
     assertTrue(1 < 2);

     assertNull(null);
     assertNotNull(new Object());
}






2、数组断言
通过 assertArrayEquals 方法来判断两个对象或原始类型的数组是否相等

@Test
@DisplayName("array assertion")
public void array() {
 assertArrayEquals(new int[]{1, 2}, new int[] {1, 2});
}




3、组合断言
assertAll 方法接受多个 org.junit.jupiter.api.Executable 函数式接口的实例作为要验证的断言，可以通过 lambda 表达式很容易的提供这些断言

@Test
@DisplayName("assert all")
public void all() {
 assertAll("Math",
    () -> assertEquals(2, 1 + 1),
    () -> assertTrue(1 > 0)
 );
}


4、异常断言
在JUnit4时期，想要测试方法的异常情况时，需要用@Rule注解的ExpectedException变量还是比较麻烦的。而JUnit5提供了一种新的断言方式Assertions.assertThrows() ,配合函数式编程就可以进行使用。

@Test
@DisplayName("异常测试")
public void exceptionTest() {
    ArithmeticException exception = Assertions.assertThrows(
           //扔出断言异常
            ArithmeticException.class, () -> System.out.println(1 % 0));

}

5、超时断言
Junit5还提供了Assertions.assertTimeout() 为测试方法设置了超时时间

@Test
@DisplayName("超时测试")
public void timeoutTest() {
    //如果测试方法时间超过1s将会异常
    Assertions.assertTimeout(Duration.ofMillis(1000), () -> Thread.sleep(500));
}


6、快速失败
通过 fail 方法直接使得测试失败

@Test
@DisplayName("fail")
public void shouldFail() {
 fail("This should fail");
}



4、前置条件（assumptions）
JUnit 5 中的前置条件（assumptions【假设】）类似于断言，不同之处在于不满足的断言会使得测试方法失败，而不满足的前置条件只会使得测试方法的执行终止。
前置条件可以看成是测试方法执行的前提，当该前提不满足时，就没有继续执行的必要。


@DisplayName("前置条件")
public class AssumptionsTest {
 private final String environment = "DEV";
 
 @Test
 @DisplayName("simple")
 public void simpleAssume() {
    assumeTrue(Objects.equals(this.environment, "DEV"));
    assumeFalse(() -> Objects.equals(this.environment, "PROD"));
 }
 
 @Test
 @DisplayName("assume then do")
 public void assumeThenDo() {
    assumingThat(
       Objects.equals(this.environment, "DEV"),
       () -> System.out.println("In DEV")
    );
 }
}


assumeTrue 和 assumFalse 确保给定的条件为 true 或 false，不满足条件会使得测试执行终止。
assumingThat 的参数是表示条件的布尔值和对应的 Executable 接口的实现对象。只有条件满足时，Executable 对象才会被执行；当条件不满足时，测试执行并不会终止。






5、嵌套测试

JUnit 5 可以通过 Java 中的内部类和@Nested 注解实现嵌套测试，从而可以更好的把相关的测试方法组织在一起。在内部类中可以使用@BeforeEach 和@AfterEach 注解，而且嵌套的层次没有限制。


@DisplayName("A stack")
class TestingAStackDemo {

    Stack<Object> stack;

    @Test
    @DisplayName("is instantiated with new Stack()")
    void isInstantiatedWithNew() {
        new Stack<>();
    }

    @Nested
    @DisplayName("when new")
    class WhenNew {

        @BeforeEach
        void createNewStack() {
            stack = new Stack<>();
        }

        @Test
        @DisplayName("is empty")
        void isEmpty() {
            assertTrue(stack.isEmpty());
        }

        @Test
        @DisplayName("throws EmptyStackException when popped")
        void throwsExceptionWhenPopped() {
            assertThrows(EmptyStackException.class, stack::pop);
        }

        @Test
        @DisplayName("throws EmptyStackException when peeked")
        void throwsExceptionWhenPeeked() {
            assertThrows(EmptyStackException.class, stack::peek);
        }

        @Nested
        @DisplayName("after pushing an element")
        class AfterPushing {

            String anElement = "an element";

            @BeforeEach
            void pushAnElement() {
                stack.push(anElement);
            }

            @Test
            @DisplayName("it is no longer empty")
            void isNotEmpty() {
                assertFalse(stack.isEmpty());
            }

            @Test
            @DisplayName("returns the element when popped and is empty")
            void returnElementWhenPopped() {
                assertEquals(anElement, stack.pop());
                assertTrue(stack.isEmpty());
            }

            @Test
            @DisplayName("returns the element when peeked but remains not empty")
            void returnElementWhenPeeked() {
                assertEquals(anElement, stack.peek());
                assertFalse(stack.isEmpty());
            }
        }
    }
}








6、参数化测试
参数化测试是JUnit5很重要的一个新特性，它使得用不同的参数多次运行测试成为了可能，也为我们的单元测试带来许多便利。

利用@ValueSource等注解，指定入参，我们将可以使用不同的参数进行多次单元测试，而不需要每新增一个参数就新增一个单元测试，省去了很多冗余代码。

@ValueSource: 为参数化测试指定入参来源，支持八大基础类以及String类型,Class类型
@NullSource: 表示为参数化测试提供一个null的入参
@EnumSource: 表示为参数化测试提供一个枚举入参
@CsvFileSource：表示读取指定CSV文件内容作为参数化测试入参
@MethodSource：表示读取指定方法的返回值作为参数化测试入参(注意方法返回需要是一个流)


当然如果参数化测试仅仅只能做到指定普通的入参还达不到让我觉得惊艳的地步。
让我真正感到他的强大之处的地方在于他可以支持外部的各类入参。
如:CSV,YML,JSON 文件甚至方法的返回值也可以作为入参。只需要去实现ArgumentsProvider接口，任何外部文件都可以作为它的入参。

@ParameterizedTest
@ValueSource(strings = {"one", "two", "three"})
@DisplayName("参数化测试1")
public void parameterizedTest1(String string) {
    System.out.println(string);
    Assertions.assertTrue(StringUtils.isNotBlank(string));
}


@ParameterizedTest
@MethodSource("method")    //指定方法名
@DisplayName("方法来源参数")
public void testWithExplicitLocalMethodSource(String name) {
    System.out.println(name);
    Assertions.assertNotNull(name);
}

static Stream<String> method() {
    return Stream.of("apple", "banana");
}













7、迁移指南
在进行迁移的时候需要注意如下的变化：
● 注解在 org.junit.jupiter.api 包中，断言在 org.junit.jupiter.api.Assertions 类中，前置条件在 org.junit.jupiter.api.Assumptions 类中。
● 把@Before 和@After 替换成@BeforeEach 和@AfterEach。
● 把@BeforeClass 和@AfterClass 替换成@BeforeAll 和@AfterAll。
● 把@Ignore 替换成@Disabled。
● 把@Category 替换成@Tag。
● 把@RunWith、@Rule 和@ClassRule 替换成@ExtendWith。































------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

8、指标监控




SpringBoot Actuator

简介
未来每一个微服务在云上部署以后，我们都需要对其进行监控、追踪、审计、控制等。SpringBoot就抽取了Actuator场景，使得我们每个微服务快速引用即可获得生产级别的应用监控、审计等功能。

<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-actuator</artifactId>
</dependency>



--------------------
1.x与2.x的不同





--------------------
如何使用


● 引入场景
● 访问 http://localhost:8080/actuator/**
● 暴露所有监控信息为HTTP


management:
  endpoints:
    enabled-by-default: true #暴露所有端点信息
    web:
      exposure:
        include: '*'  #以web方式暴露


● 测试
http://localhost:8080/actuator/beans
http://localhost:8080/actuator/configprops
http://localhost:8080/actuator/metrics
http://localhost:8080/actuator/metrics/jvm.gc.pause
http://localhost:8080/actuator/endpointName/detailPath
。。。。



可视化
https://github.com/codecentric/spring-boot-admin













--------------------------------------------------------------------------------
Actuator Endpoint


最常使用的端点

auditevents	暴露当前应用程序的审核事件信息。需要一个AuditEventRepository组件。
beans	显示应用程序中所有Spring Bean的完整列表。
caches	暴露可用的缓存。
conditions	显示自动配置的所有条件信息，包括匹配或不匹配的原因。
configprops	显示所有@ConfigurationProperties。
env	暴露Spring的属性ConfigurableEnvironment
flyway	显示已应用的所有Flyway数据库迁移。 需要一个或多个Flyway组件。
health	显示应用程序运行状况信息。
httptrace	显示HTTP跟踪信息（默认情况下，最近100个HTTP请求-响应）。需要一个HttpTraceRepository组件。
info	显示应用程序信息。
integrationgraph	显示Spring integrationgraph 。需要依赖spring-integration-core。
loggers	显示和修改应用程序中日志的配置。
liquibase	显示已应用的所有Liquibase数据库迁移。需要一个或多个Liquibase组件。
metrics	显示当前应用程序的“指标”信息。
mappings	显示所有@RequestMapping路径列表。
scheduledtasks	显示应用程序中的计划任务。
sessions	允许从Spring Session支持的会话存储中检索和删除用户会话。需要使用Spring Session的基于Servlet的Web应用程序。
shutdown	使应用程序正常关闭。默认禁用。
startup	显示由ApplicationStartup收集的启动步骤数据。需要使用SpringApplication进行配置BufferingApplicationStartup。
threaddump	执行线程转储。



如果您的应用程序是Web应用程序（Spring MVC，Spring WebFlux或Jersey），则可以使用以下附加端点：

ID	描述
heapdump	返回hprof堆转储文件。
jolokia	通过HTTP暴露JMX bean（需要引入Jolokia，不适用于WebFlux）。需要引入依赖jolokia-core。
logfile	返回日志文件的内容（如果已设置logging.file.name或logging.file.path属性）。支持使用HTTPRange标头来检索部分日志文件的内容。
prometheus	以Prometheus服务器可以抓取的格式公开指标。需要依赖micrometer-registry-prometheus。


最常用的Endpoint
● Health：监控状况
● Metrics：运行时指标
● Loggers：日志记录









Health Endpoint
健康检查端点，我们一般用于在云平台，平台会定时的检查应用的健康状况，我们就需要Health Endpoint可以为平台返回当前应用的一系列组件健康状况的集合。
重要的几点：
● health endpoint返回的结果，应该是一系列健康检查后的一个汇总报告
● 很多的健康检查默认已经自动配置好了，比如：数据库、redis等
● 可以很容易的添加自定义的健康检查机制






Metrics Endpoint
提供详细的、层级的、空间指标信息，这些信息可以被pull（主动推送）或者push（被动获取）方式得到；
● 通过Metrics对接多种监控系统
● 简化核心Metrics开发
● 添加自定义Metrics或者扩展已有Metrics






管理Endpoints
1、开启与禁用Endpoints
● 默认所有的Endpoint除过shutdown都是开启的。
● 需要开启或者禁用某个Endpoint。配置模式为  management.endpoint.<endpointName>.enabled = true

management:
  endpoint:
    beans:
      enabled: true





或者禁用所有的Endpoint然后手动开启指定的Endpoint
management:
  endpoints:
    enabled-by-default: false
  endpoint:
    beans:
      enabled: true
    health:
      enabled: true





暴露Endpoints
支持的暴露方式
● HTTP：默认只暴露health和info Endpoint
● JMX：默认暴露所有Endpoint
● 除过health和info，剩下的Endpoint都应该进行保护访问。如果引入SpringSecurity，则会默认配置安全访问规则


ID	JMX	Web
auditevents	Yes	No
beans	Yes	No
caches	Yes	No
conditions	Yes	No
configprops	Yes	No
env	Yes	No
flyway	Yes	No
health	Yes	Yes
heapdump	N/A	No
httptrace	Yes	No
info	Yes	Yes
integrationgraph	Yes	No
jolokia	N/A	No
logfile	N/A	No
loggers	Yes	No
liquibase	Yes	No
metrics	Yes	No
mappings	Yes	No
prometheus	N/A	No
scheduledtasks	Yes	No
sessions	Yes	No
shutdown	Yes	No
startup	Yes	No
threaddump	Yes	No















定制 Endpoint
1、定制 Health 信息。实现HealthIndicator接口。名字必须是xxxHealthIndicator

import org.springframework.boot.actuate.health.Health;
import org.springframework.boot.actuate.health.HealthIndicator;
import org.springframework.stereotype.Component;

@Component
public class MyHealthIndicator implements HealthIndicator {

    @Override
    public Health health() {
        int errorCode = check(); // perform some specific health check
        if (errorCode != 0) {
            return Health.down().withDetail("Error Code", errorCode).build();
        }
        return Health.up().build();
    }

}

构建Health
Health build = Health.down()
                .withDetail("msg", "error service")
                .withDetail("code", "500")
                .withException(new RuntimeException())
                .build();



management:
    health:
      enabled: true
      show-details: always #总是显示详细信息。可显示每个模块的状态信息


定制健康信息方式2.继承AbstractHealthIndicator

@Component
public class MyComHealthIndicator extends AbstractHealthIndicator {

    /**
     * 真实的检查方法
     * @param builder
     * @throws Exception
     */
    @Override
    protected void doHealthCheck(Health.Builder builder) throws Exception {
        //mongodb。  获取连接进行测试
        Map<String,Object> map = new HashMap<>();
        // 检查完成
        if(1 == 2){
//            builder.up(); //健康
            builder.status(Status.UP);
            map.put("count",1);
            map.put("ms",100);
        }else {
//            builder.down();
            builder.status(Status.OUT_OF_SERVICE);
            map.put("err","连接超时");
            map.put("ms",3000);
        }


        builder.withDetail("code",100)
                .withDetails(map);

    }
}







定制info信息
常用两种方式
1、编写配置文件
info:
  appName: boot-admin
  version: 2.0.1
  mavenProjectName: @project.artifactId@  #使用@@可以获取maven的pom文件值
  mavenProjectVersion: @project.version@


2、编写InfoContributor

import java.util.Collections;

import org.springframework.boot.actuate.info.Info;
import org.springframework.boot.actuate.info.InfoContributor;
import org.springframework.stereotype.Component;

@Component
public class ExampleInfoContributor implements InfoContributor {

    @Override
    public void contribute(Info.Builder builder) {
        builder.withDetail("example",
                Collections.singletonMap("key", "value"));
    }

}



http://localhost:8080/actuator/info 会输出以上方式返回的所有info信息



3、定制Metrics信息
1、SpringBoot支持自动适配的Metrics
● JVM metrics, report utilization of:
  ○ Various memory and buffer pools
  ○ Statistics related to garbage collection
  ○ Threads utilization
  ○ Number of classes loaded/unloaded
● CPU metrics
● File descriptor metrics
● Kafka consumer and producer metrics
● Log4j2 metrics: record the number of events logged to Log4j2 at each level
● Logback metrics: record the number of events logged to Logback at each level
● Uptime metrics: report a gauge for uptime and a fixed gauge representing the application’s absolute start time
● Tomcat metrics (server.tomcat.mbeanregistry.enabled must be set to true for all Tomcat metrics to be registered)
● Spring Integration metrics





2、增加定制Metrics

class MyService{
    Counter counter;
    public MyService(MeterRegistry meterRegistry){
         counter = meterRegistry.counter("myservice.method.running.counter");
    }

    public void hello() {
        counter.increment();
    }
}


//也可以使用下面的方式
@Bean
MeterBinder queueSize(Queue queue) {
    return (registry) -> Gauge.builder("queueSize", queue::size).register(registry);
}






4、定制Endpoint

@Component
@Endpoint(id = "container")
public class DockerEndpoint {


    @ReadOperation
    public Map getDockerInfo(){
        return Collections.singletonMap("info","docker started...");
    }

    @WriteOperation
    private void restartDocker(){
        System.out.println("docker restarted....");
    }

}

场景：开发ReadinessEndpoint来管理程序是否就绪，或者LivenessEndpoint来管理程序是否存活；
当然，这个也可以直接使用 https://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-features.html#production-ready-kubernetes-probes
























------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

原理解析




Profile功能
为了方便多环境适配，springboot简化了profile功能。


1、application-profile功能
● 默认配置文件  application.yaml；任何时候都会加载
● 指定环境配置文件  application-{env}.yaml
● 激活指定环境
  ○ 配置文件激活  spring.profiles.active = env
  ○ 命令行激活：java -jar xxx.jar --spring.profiles.active=prod  --person.name=haha
    ■ 修改配置文件的任意值，命令行优先
● 默认配置与环境配置同时生效
● 同名配置项，profile配置优先


2、@Profile条件装配功能
@Configuration(proxyBeanMethods = false)
@Profile("production")
public class ProductionConfiguration {

    // ...

}




3、profile分组
spring.profiles.group.production[0]=proddb
spring.profiles.group.production[1]=prodmq

使用：--spring.profiles.active=production  激活








2、外部化配置
https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-external-config

1. Default properties (specified by setting SpringApplication.setDefaultProperties).
2. @PropertySource annotations on your @Configuration classes. Please note that such property sources are not added to the Environment until the application context is being refreshed. This is too late to configure certain properties such as logging.* and spring.main.* which are read before refresh begins.
3. Config data (such as application.properties files)
4. A RandomValuePropertySource that has properties only in random.*.
5. OS environment variables.
6. Java System properties (System.getProperties()).
7. JNDI attributes from java:comp/env.
8. ServletContext init parameters.
9. ServletConfig init parameters.
10. Properties from SPRING_APPLICATION_JSON (inline JSON embedded in an environment variable or system property).
11. Command line arguments.
12. properties attribute on your tests. Available on @SpringBootTest and the test annotations for testing a particular slice of your application.
13. @TestPropertySource annotations on your tests.
14. Devtools global settings properties in the $HOME/.config/spring-boot directory when devtools is active.





1、外部配置源
常用：Java属性文件、YAML文件、环境变量、命令行参数；



2、配置文件查找位置
(1) classpath 根路径
(2) classpath 根路径下config目录
(3) jar包当前目录
(4) jar包当前目录的config目录
(5) /config子目录的直接子目录
下面的优先级高。


3、配置文件加载顺序：
1. 　当前jar包内部的application.properties和application.yml
2. 　当前jar包内部的application-{profile}.properties 和 application-{profile}.yml
3. 　引用的外部jar包的application.properties和application.yml
4. 　引用的外部jar包的application-{profile}.properties 和 application-{profile}.yml




4、指定环境优先，外部优先，后面的可以覆盖前面的同名配置项





3、自定义starter

1、starter启动原理
● starter-pom引入 autoconfigurer 包
● autoconfigure包中配置使用 META-INF/spring.factories 中 EnableAutoConfiguration 的值，使得项目启动加载指定的自动配置类
● 编写自动配置类 xxxAutoConfiguration -> xxxxProperties
  ○ @Configuration
  ○ @Conditional
  ○ @EnableConfigurationProperties
  ○ @Bean
  ○ ......
引入starter --- xxxAutoConfiguration --- 容器中放入组件 ---- 绑定xxxProperties ---- 配置项




2、自定义starter
atguigu-hello-spring-boot-starter（启动器）
atguigu-hello-spring-boot-starter-autoconfigure（自动配置包）



自定义starter总结：
1、创建两个模块(maven项目即可)，xxxstarter，xxxautoconfigure。
2、在xxxstarter模块的pom文件中引入xxxautoconfigure模块的依赖
3、在xxxautoconfigure编写自己的代码。
4、在xxxautoconfigure模块中配置META-INF/spring.factorie文件，并配置需要自动配置的类。EnableAutoConfiguration 的值，使得项目启动加载指定的自动配置类
5、mvn install到本地仓库就可以在其他项目中使用该starter了。




------------------------------------------------------------------------------------
SpringBoot原理
Spring原理【Spring注解】、SpringMVC原理、自动配置原理、SpringBoot原理



SpringBoot启动过程


● 创建 SpringApplication
  ○ 保存一些信息。
  ○ 判定当前应用的类型。ClassUtils。Servlet
  ○ bootstrappers：初始启动引导器（List<Bootstrapper>）：去spring.factories文件中找 org.springframework.boot.Bootstrapper
  ○ 找 ApplicationContextInitializer；去spring.factories找 ApplicationContextInitializer
    ■ List<ApplicationContextInitializer<?>> initializers
  ○ 找 ApplicationListener  ；应用监听器。去spring.factories找 ApplicationListener
    ■ List<ApplicationListener<?>> listeners
● 运行 SpringApplication
  ○ StopWatch
  ○ 记录应用的启动时间
  ○ 创建引导上下文（Context环境）createBootstrapContext()
    ■ 获取到所有之前的 bootstrappers 挨个执行 intitialize() 来完成对引导启动器上下文环境设置
  ○ 让当前应用进入headless模式。java.awt.headless
  ○ 获取所有 RunListener（运行监听器）【为了方便所有Listener进行事件感知】
    ■ getSpringFactoriesInstances 去spring.factories找 SpringApplicationRunListener. 
  ○ 遍历 SpringApplicationRunListener 调用 starting 方法；
    ■ 相当于通知所有感兴趣系统正在启动过程的人，项目正在 starting。
  ○ 保存命令行参数；ApplicationArguments
  ○ 准备环境 prepareEnvironment（）;
    ■ 返回或者创建基础环境信息对象。StandardServletEnvironment
    ■ 配置环境信息对象。
      ● 读取所有的配置源的配置属性值。
    ■ 绑定环境信息
    ■ 监听器调用 listener.environmentPrepared()；通知所有的监听器当前环境准备完成
  ○ 创建IOC容器（createApplicationContext（））
    ■ 根据项目类型（Servlet）创建容器，
    ■ 当前会创建 AnnotationConfigServletWebServerApplicationContext
  ○ 准备ApplicationContext IOC容器的基本信息   prepareContext()
    ■ 保存环境信息
    ■ IOC容器的后置处理流程。
    ■ 应用初始化器；applyInitializers；
      ● 遍历所有的 ApplicationContextInitializer 。调用 initialize.。来对ioc容器进行初始化扩展功能
      ● 遍历所有的 listener 调用 contextPrepared。EventPublishRunListenr；通知所有的监听器contextPrepared
    ■ 所有的监听器 调用 contextLoaded。通知所有的监听器 contextLoaded；
  ○ 刷新IOC容器。refreshContext
    ■ 创建容器中的所有组件（Spring注解）
  ○ 容器刷新完成后工作？afterRefresh
  ○ 所有监听 器 调用 listeners.started(context); 通知所有的监听器 started
  ○ 调用所有runners；callRunners()
    ■ 获取容器中的 ApplicationRunner 
    ■ 获取容器中的  CommandLineRunner
    ■ 合并所有runner并且按照@Order进行排序
    ■ 遍历所有的runner。调用 run 方法
  ○ 如果以上有异常，
    ■ 调用Listener 的 failed
  ○ 调用所有监听器的 running 方法  listeners.running(context); 通知所有的监听器 running 
  ○ running如果有问题。继续通知 failed 。调用所有 Listener 的 failed；通知所有的监听器 failed


public interface Bootstrapper {

	/**
	 * Initialize the given {@link BootstrapRegistry} with any required registrations.
	 * @param registry the registry to initialize
	 */
	void intitialize(BootstrapRegistry registry);

}


@FunctionalInterface
public interface ApplicationRunner {

	/**
	 * Callback used to run the bean.
	 * @param args incoming application arguments
	 * @throws Exception on error
	 */
	void run(ApplicationArguments args) throws Exception;

}


@FunctionalInterface
public interface CommandLineRunner {

	/**
	 * Callback used to run the bean.
	 * @param args incoming main method arguments
	 * @throws Exception on error
	 */
	void run(String... args) throws Exception;

}




Application Events and Listeners

https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-application-events-and-listeners
ApplicationContextInitializer
ApplicationListener
SpringApplicationRunListener






ApplicationRunner 与 CommandLineRunner























